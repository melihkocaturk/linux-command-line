<!doctype html>
<html lang="tr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="Melih Kocatürk">
    <meta name="description" content="Linux komut satırını bir profesyonel gibi kullanın.">
    <link rel="stylesheet" href="assets/css/vendor.css" />
    <link rel="stylesheet" href="assets/css/style.css" />

    <title>sudo</title>
  </head>
  <body>

    <!-- header -->
    <header class="header header-sticky header-minimal-light">
      <div class="container">
        <div class="row">
          <nav class="navbar navbar-expand-lg navbar-light">
            <a href="index.html" class="navbar-brand"><img src="assets/images/logo.svg" alt="Logo"></a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarSupportedContent">
              <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                  <a class="nav-link" href="index.html">Anasayfa</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="resources.html">Kaynaklar</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="https://www.tradepub.com/category/information-technology-servers-and-linux-server-os/806/" target="blank" rel="nofollow">Ücretsiz Kitaplar</a>
                </li>
              </ul>
              <ul class="navbar-nav">
                <li class="nav-item">
                  <a class="nav-link" href="index.html">Türkçe</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="http://linuxcommand.org/" target="blank" rel="nofollow">English</a>
                </li>
              </ul>
            </div>
          </nav>
        </div>
      </div>
    </header>
    <!-- / header -->

    <section>
      <div class="container">
        <div class="row justify-content-between">

          <!-- toc -->
          <aside class="col-lg-3">
            <div class="sticky sticky-with-header">
              <div class="boxed bg-dark text-white mb-3 mb-lg-0">
                <ul id="page-nav" class="nav flex-column nav-vertical">
                  <li class="nav-item">
                    <a class="nav-link" data-toggle="collapse" href="#menu-1" role="button" aria-expanded="false" aria-controls="menu-1">Kabuk</a>
                    <div class="collapse show" id="menu-1" data-parent="#page-nav">
                      <ul class="nav flex-column">
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-1">Kabuk Nedir?</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-2">Navigasyon</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-3">Sistemi Keşfetmek</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-4">Dosya ve Dizinleri Yönetmek</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-5">Komutlarla Çalışmak</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-6">Yönlendirme</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-7">Dünyayı Kabuk Olarak Görmek</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-8">Klavye Püf Noktaları</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-9">İzinler</a>
                        </li>
                        <li class="nav-item">
                          <a class="nav-link" href="learning-the-shell.html#section-10">Süreçler</a>
                        </li>
                      </ul>
                    </div>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" data-toggle="collapse" href="#menu-2" role="button" aria-expanded="false" aria-controls="menu-2">Yapılandırma</a>
                    <div class="collapse" id="menu-2" data-parent="#page-nav">
                      <div>
                        <ul class="nav flex-column">
                          <li class="nav-item">
                            <a class="nav-link" href="configuration-and-the-environment.html#section-1">Ortam</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="onfiguration-and-the-environment.html#section-2">Vi'ye Giriş</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="onfiguration-and-the-environment.html#section-3">Komut İstemini Özelleştirme</a>
                          </li>
                        </ul>
                      </div>
                    </div>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" data-toggle="collapse" href="#menu-3" role="button" aria-expanded="false" aria-controls="menu-3">Görevler ve Araçlar</a>
                    <div class="collapse" id="menu-3" data-parent="#page-nav">
                      <div>
                        <ul class="nav flex-column">
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-1">Paket Yönetimi</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-2">Depolama Ortamı</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-3">Ağ</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-4">Dosya Arama</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-5">Arşivleme ve Yedekleme</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-6">Düzenli İfadeler</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-7">Metin İşleme</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-8">Çıktıyı Biçimlendirme</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-9">Çıktı Almak</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="common-tasks-and-essential-tools.html#section-10">Programları Derlemek</a>
                          </li>
                        </ul>
                      </div>
                    </div>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" data-toggle="collapse" href="#menu-4" role="button" aria-expanded="false" aria-controls="menu-4">Script Yazmak</a>
                    <div class="collapse" id="menu-4" data-parent="#page-nav">
                      <div>
                        <ul class="nav flex-column">
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-1">İlk Scriptinizi Yazmak</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-2">Projeye Başlamak</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-3">Yukarıdan Aşağıya Tasarım</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-4">Akış Kontrolü: if</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-5">Klavye Girişini Okumak</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-6">Akış Kontrölü: while/until</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-7">Sorun Giderme</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-8">Akış Kontrolü: case</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-9">Konuma Bağlı Parametreler</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-10">Akış Kontrolü: for</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-11">Dizeler ve Sayılar</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-12">Diziler</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" href="writing-shell-scripts.html#section-13">Sıradışı Şeyler</a>
                          </li>
                        </ul>
                      </div>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
          </aside>
          <!-- / toc -->

          <!-- content -->
          <article id="content" class="col-lg-7">
            <h1 class="h2 font-weight-light mb-4">Bölüm 1 - <strong>Kabuk</strong></h1>

            <!-- what is the shell? -->
            <section id="section-1">
              <h2 class="section-title-2 mb-2">Kabuk Nedir? <a data-scroll="" href="#section-1" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>Komut satırından bahsettiğimiz zaman, gerçekte kabuktan bahsediyoruz. Kabuk, klavye komutlarını alan ve bunları yürütmek için işletim sistemine ileten bir programdır. Neredeyse tüm Linux dağıtımları <code>bash</code> denilen bir kabuk programıyla beraber gelmektedir. "bash" adı, "Bourne Again Shell" in kısaltmasıdır ve <em>Steve Bourne</em> tarafından yazılmış orijinal Unix kabuk programı olan <code>sh</code> için geliştirilmiş bir alternatiftir.</p>
              <h3 class="h4 mb-2">Terminal emülatörleri</h3>
              <p>Bir grafik kullanıcı arayüzü (GUI) kullanırken, kabukla etkileşime girmek için terminal emülatörü adı verilen başka bir programa ihtiyacınız vardır. KDE <code>konsole</code> ve GNOME <code>gnome-terminal</code> kullanır, ancak büyük olasılıkla menümüzde basitçe "terminal" olarak adlandırılmıştır. Linux için kullanılabilecek çok sayıda başka terminal emülatörü mevcuttur, ancak hepsi temelde aynı şeyi yapar; kabuğa erişim izni verir.</p>
              <h3 class="h4 mb-2">İlk tuş vuruşlarınız</h3>
              <p>Öyleyse başlayalım. Terminal emülatörünü başlatın! Açıldığında şöyle bir şey görmelisiniz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$</code></pre>
              <p>Buna kabuk istemi adı verilir ve kabuk giriş kabul etmeye hazır olduğunda görünür. Dağıtıma bağlı olarak görünüşü biraz değişse de, tipik olarak <code>username@machinename</code> içerecektir, bunu geçerli çalışma dizininiz ve dolar işareti takip eder.</p>
              <div class="row">
                <div class="col">
                  <div class="alert alert-info" role="alert">
                    <h4>Not</h4>
                    <p>Komut isteminin son karakteri dolar işareti yerine pound işareti (<code>#</code>) ise, terminal oturumunda <em>superuser</em> ayrıcalıkları vardır. Bu, <em>root</em> kullanıcı olarak oturum açtığınız veya superuser (yönetici) ayrıcalıkları sağlayan bir terminal emülatörü seçtiğiniz anlamına gelir.</p>
                    <i class="icon-info-circle"></i>
                  </div>
                </div>
              </div>
              <p>İşlerin şimdiye kadar iyi gittiğini varsayalım ve birşeyler yazmaya çalışalım. Bazı anlamsız ifadeler girin:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ kaekfjaeifj</code></pre>
              <p>Kabuk bu komutun anlamsız olduğunu söyler ve bize bir şans daha verir.</p>
              <pre><code class="language-bash">bash: kaekfjaeifj: command not found
[me@linuxbox ~]$</code></pre>
              <h4 class="h5 mb-2">Komut geçmişi</h4>
              <p>Yukarı ok tuşuna basarsanız, önceki komutun <code>kaekfjaeifj</code> komut isteminden sonra tekrar göründüğünü göreceğiz. Buna komut geçmişi denir. Çoğu Linux dağıtımı, varsayılan olarak son 1000 komutu hatırlar. Aşağı ok tuşuna basarsanız, önceki komut kaybolur.</p>
              <h4 class="h5 mb-2">İmleç hareketi</h4>
              <p>Yukarı ok tuşuna tekrar basarak önceki komutu geri çağırın. Sol ve sağ ok tuşlarını denerseniz, imleci komut satırının herhangi bir yerinde nasıl konumlandıracağımızı göreceksiniz. Bu komutları düzenlemeyi kolaylaştırır.</p>
              <div class="row">
                <div class="col">
                  <div class="alert alert-info" role="alert">
                    <h4>Not</h4>
                    <p>Bir terminal penceresine kopyalama ve yapıştırma yapmak için <code>Ctrl-c</code> ve <code>Ctrl-v</code> kullanmaya çalışmayın, çünkü çalışmıyorlar. Bu kontrol kodlarının kabuk için farklı anlamları vardır ve Microsoft Windows'un piyasaya sürülmesinden yıllar önce atanmıştır.</p>
                    <p></p>
                    <i class="icon-info-circle"></i>
                  </div>
                </div>
              </div>
              <h3 class="h4 mb-2">Bazı basit komutları deneyin</h3>
              <p>Artık terminal emülatörüne metin girmeyi öğrendiğimize göre, birkaç basit komut deneyelim. Şimdiki saati ve tarihi gösteren <code>date</code> komutuyla başlayalım.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ date
Thu Mar 8 15:09:41 EST 2018</code></pre>
              <p>İlgili başka bir komut, varsayılan olarak geçerli ayın takvimini görüntüleyen <code>cal</code>'dır.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cal
March 2018
Su Mo Tu We Th Fr Sa
1 2 3
4 5 6 7 8 9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31</code></pre>
              <p>Disk sürücülerimizde mevcut boş alan miktarını görmek için <code>df</code> komutunu girin.</p>
              <pre><code class="language-bash">Filesystem  1K-blocks Used      Available Use%  Mounted on
/dev/sda2   15115452  5012392   9949716   34%   /
/dev/sda5   59631908  26545424  30008432  47%   /home
/dev/sda1   147764    17370     122765    13%   /boot
tmpfs       256856    0         256856    0%    /dev/shm</code></pre>
              <p>Aynı şekilde, boş hafıza miktarını görüntülemek için, <code>free</code> komutu girin.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ free
      total         used    free    shared  buffers cached
Mem:  513712        503976  9736    0       5312    122916
-/+ buffers/cache:  375748  137964
Swap:               104712  947536</code></pre>
              <h3 class="h4 mb-2">Terminal oturumunu sonlandırmak</h3>
              <p>Bir terminal oturumunu, emülatör penceresini kapatarak, kabuk isteminde <code>exit</code> komutunu girerek veya <code>Ctrl-d</code> tuşlarına basarak sonlandırabiliriz.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ exit</code></pre>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>Perde arkasındaki konsol</h4>
                    <p>Çalışan bir terminal emülatörü olmasa bile, birkaç terminal oturumu grafik masaüstünün arkasında çalışmaya devam eder. Çoğu Linux dağıtımında <code>Ctrl-Alt-F1</code>'den <code>Ctrl-Alt-F6</code>'ya kadar basarak sanal terminal veya sanal konsol olarak adlandırılan bu oturumlara erişebilirsiniz. Bir sanal konsoldan diğerine geçmek için, <code>Alt-F1</code> ila <code>Alt-F6</code> arasındaki tuşlara basın. Çoğu sistemde <code>Alt-F7</code> ile grafik masaüstüne geri dönebilirsiniz.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
            </section>
            <!-- / what is the shell? -->

            <!-- navigation -->
            <section id="section-2">
              <h2 class="section-title-2 mb-2">Navigasyon <a data-scroll="" href="#section-2" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>Öğrenmemiz gereken ilk şey (nasıl yazılacağının yanı sıra) Linux sistemimizdeki dosya sisteminde nasıl gezileceğidir. Bu bölümde aşağıdaki komutları öğreneceksiniz:</p>
              <ul>
                <li><code>pwd</code> - Geçerli çalışma dizininin adını yazdır</li>
                <li><code>cd</code> - Dizini değiştir</li>
                <li><code>ls</code> - Dizin içeriğini listele</li>
              </ul>
              <h3 class="h4 mb-2">Dosya sistemi ağacını anlamak</h3>
              <p>Windows gibi, Linux işletim sistemide dosyalarını hiyerarşik dizin yapısı şeklinde düzenler. Bu, dosyaları ve diğer dizinleri içerebilen, ağaç benzeri bir dizin (bazen diğer sistemlerde klasörler olarak adlandırılır) düzeninde organize edildikleri anlamına gelir. Dosya sistemindeki ilk dizine kök dizin adı verilir. Kök dizin, daha fazla dosya ve alt dizin vb. içeren dosyalar ve alt dizinler içerir.</p>
              <p>Her depolama aygıtı için ayrı bir dosya sistemi ağacına sahip olan Windows'tan farklı olarak, Linux gibi Unix benzeri sistemlerin, bilgisayara ne kadar sürücü veya depolama aygıtı takıldığına bakılmaksızın her zaman tek bir dosya sistemi ağacına sahip olduğunu unutmayın.</p>
              <h3 class="h4 mb-2">Geçerli çalışma dizini</h3>
              <p>Çoğumuz muhtemelen, Şekil 1'de görüldüğü gibi dosya sistemi ağacını temsil eden bir grafik dosya yöneticisine aşinayız. Ağaca genellikle yukarıdan aşağıya doğru bakıldığına dikkat edin, yani üstte kök bulunur ve dallar aşağıya doğru iner.</p>
              <p>Ancak, komut satırında resim yoktur, bu nedenle dosya sistemi ağacında gezinmek için farklı bir şekilde düşünmemiz gerekir.</p>
              <div class="text-center mb-2">
                <img src="assets/images/file-system-tree.png" alt="Dosya sistemi ağacı">
                <br>
                <em>Şekil 1: Dosya yöneticisi tarafından<br> gösterilen dosya sistemi ağacı</em>
              </div>
              <p>Dosya sisteminin ağaç şeklinde bir labirent olduğunu ve bunun ortasında durduğunuzu hayal edin. Herhangi bir zamanda, dizinde bulunan dosyaları, üst dizine giden yolu ve alt dizinleri görebiliriz. Bulunduğumuz dizine geçerli çalışma dizini denir. Geçerli çalışma dizinini görüntülemek için, <code>pwd</code> (print working directory) komutunu kullanın.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ pwd
/home/me</code></pre>
              <p>Sisteme ilk giriş yaptığınızda (veya bir terminal emülatör oturumu başlattığımızda) geçerli çalışma dizini ana dizininize ayarlanır. Her kullanıcı hesabına kendi giriş dizini verilir ve normal bir kullanıcıya yazma izni verilen tek yer burasıdır.</p>
              <h3 class="h4 mb-2">Dizin içeriğini listelemek</h3>
              <p>Geçerli çalışma dizinindeki dosyaları ve dizinleri listelemek için <code>ls</code> komutunu kullanın.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls
Desktop Documents Music Pictures Public Templates Videos</code></pre>
              <p>Aslında, sadece geçerli çalışma dizinini değil, herhangi bir dizinin içeriğini listelemek için <code>ls</code> komutunu kullanabiliriz ve yapabileceği başka ilginç şeylerde var. Bir sonraki bölümde <code>ls</code> ile daha fazla zaman geçireceğiz.</p>
              <h3 class="h4 mb-2">Geçerli çalışma dizinini değiştirmek</h3>
              <p>Çalışma dizininizi değiştirmek için <code>cd</code> komutunu kullanın. Bunu yapmak için, <code>cd</code> ve ardından istenen çalışma dizinin yolunu yazın. Yol, istediğimiz dizine ulaşmak için ağacın dalları boyunca gidilecek rotadır. Yol adlarını iki farklı şekilde belirtebiliriz; mutlak yol adları veya göreceli yol adları. İlk önce mutlak yollar ile ilgilenelim.</p>
              <h4 class="h5 mb-2">Mutlak yol adları</h4>
              <p>Mutlak bir yol adı kök dizin ile başlar ve istenen dizine veya dosyaya giden yol tamamlanıncaya kadar dalları takip eder. Örneğin, sistemimizde programlarımızın çoğunun kurulu olduğu bir dizin bulunur. Dizinin yol adı <code>/usr/bin</code>'dir. Bu, kök dizinde (yolun başındaki eğik çizgiyle temsil edilir) "bin" adında bir dizin içeren "usr" adında bir dizin olduğu anlamına gelir.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cd /usr/bin
[me@linuxbox bin]$ pwd
/usr/bin
[me@linuxbox bin]$ ls
...Listing of many, many files ...</code></pre>
              <p>Şimdi geçerli çalışma dizinini <code>/usr/bin</code> olarak değiştirdiğimizi ve dosyalarla dolu olduğunu görebiliyoruz. Kabuk isteminin nasıl değiştiğine dikkat edin. Kolaylık olması amacıyla genellikle çalışma dizininin adını otomatik olarak gösterecek şekilde ayarlanır.</p>
              <h4 class="h5 mb-2">Göreceli yol adları</h4>
              <p>Dosya sistemi ağacındaki göreceli konumları göstermek için birkaç özel notasyon kullanılır. Bu özel notasyonlar <code>.</code> (nokta) ve <code>..</code> (nokta nokta) dır. <code>.</code> çalışma dizinini ve <code>..</code> ana dizini ifade eder. Çalışma dizinini tekrar <code>/usr/bin</code> olarak değiştirelim.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cd /usr/bin
[me@linuxbox bin]$ pwd
/usr/bin</code></pre>
              <p>Şimdi çalışma dizinini <code>/usr/bin</code> öğesinin ana dizini olan <code>/usr</code> olarak değiştirmek istediğimizi varsayalım. Bunu iki farklı yolla yapabiliriz, mutlak bir yol adı kullanarak,</p>
              <pre><code class="language-bash">[me@linuxbox bin]$ cd /usr
[me@linuxbox usr]$ pwd
/usr</code></pre>
              <p>veya göreceli bir yol adı kullanarak.</p>
              <pre><code class="language-bash">[me@linuxbox bin]$ cd ..
[me@linuxbox usr]$ pwd
/usr</code></pre>
              <p>Aynı sonuç, iki farklı yöntem. Peki hangisini kullanmalıyız? En az yazmayı gerektireni!</p>
              <p>Aynı şekilde, çalışma dizinini <code>/usr</code>'den <code>/usr/bin</code>'e değiştirebiliriz. Bunu mutlak bir yol adı kullanarak,</p>
              <pre><code class="language-bash">[me@linuxbox usr]$ cd /usr/bin
[me@linuxbox bin]$ pwd
/usr/bin</code></pre>
              <p>veya göreceli bir yol adı kullanarak yapabiliriz.</p>
              <pre><code class="language-bash">[me@linuxbox usr]$ cd ./bin
[me@linuxbox bin]$ pwd
/usr/bin</code></pre>
              <p>Burada belirtilmesi gereken önemli bir nokta var. Neredeyse tüm durumlarda <code>./</code> ihmal edilebilir. </p>
              <pre><code class="language-bash">[me@linuxbox usr]$ cd bin</code></pre>
              <p>Genel olarak, eğer bir şey için yol belirtmezsek, çalışma dizini kabul edilecektir.</p>
              <h4 class="h5 mb-2">Bazı faydalı kısayollar</h4>
              <p>Geçerli çalışma dizininin hızlı bir şekilde değiştirilebileceği bazı kullanışlı yollar:</p>
              <ul>
                <li><code>cd</code> Çalışma dizinini giriş dizini olarak değiştirir.</li>
                <li><code>cd -</code> Çalışma dizinini önceki çalışma dizini olarak değiştirir.</li>
                <li><code>cd ~user_name</code> Çalışma dizinini <em>user_name</em> giriş dizini olarak değiştirir. Örneğin, <code>cd ~bob</code>, dizini <em>bob</em> kullanıcısının giriş dizini olarak değiştirir.</li>
              </ul>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>Dosya adları ile ilgili önemli bilgiler</h4>
                    <p>Dosyalar Linux sistemlerinde Windows gibi diğer sistemlere benzer şekilde adlandırılır, ancak bazı önemli farklılıklar vardır.</p>
                    <ol>
                      <li>Nokta karakteriyle başlayan dosya adları gizlenir. Bu sadece <code>ls</code> komutunun (<code>ls -a</code> kullanılmadıkça) onları listelemeyeceği anlamına geliyor. Hesabınız oluşturulduğunda, hesabınızla ilgili şeyleri yapılandırmak için ana dizininize birkaç gizli dosya yerleştirildi. Sonraki bölümde, ortamınızı nasıl özelleştirebileceğinizi görmek için bu dosyalardan bazılarına daha yakından bakacağız. Ayrıca, bazı uygulamalar yapılandırma ve ayar dosyalarını giriş dizininize gizli dosyalar olarak yerleştirir.</li>
                      <li>Linux'ta Unix gibi dosya adları ve komutlar büyük/küçük harf duyarlıdır. “Dosya1” ve “dosya1” farklı dosyalar olarak değerlendirilir.</li>
                      <li>Linux'ta diğer bazı işletim sistemleri gibi “dosya uzantısı” kavramı bulunmaz. Dosyaları istediğiniz gibi adlandırabilirsiniz. Bir dosyanın içeriği ve/veya amacı başka yollarla belirlenir. Unix benzeri işletim sistemleri dosyaların içeriğini/amacını belirlemek için dosya uzantılarını kullanmasa da, birçok uygulama kullanır.</li>
                      <li>Linux, boşluk ve noktalama işaretleri içerebilen uzun dosya adlarını desteklese de, noktalama işaretlerini nokta, çizgi ve alt çizgi ile sınırlandırın. En önemlisi, dosya adlarında boşluk kullanmayın. Bir dosya adındaki kelimeler arasındaki boşlukları temsil etmesi için alt çizgi karakterini kullanın. Kendinize daha sonra teşekkür edeceksiniz.</li>
                    </ol>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
            </section>
            <!-- / navigation -->

            <!-- exploring the system -->
            <section id="section-3">
              <h2 class="section-title-2 mb-2">Sistemi Keşfetmek <a data-scroll="" href="#section-3" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>Artık dosya sisteminde nasıl dolaşılacağını bildiğinize göre, Linux'ta rehberli bir tur atmanın zamanı geldi. Ancak başlamadan önce, yol boyunca yararlı olacak birkaç komut öğreneceğiz.</p>
              <ul>
                <li><code>ls</code> - Dizin içeriğini listele</li>
                <li><code>file</code> - Dosya türünü belirle</li>
                <li><code>less</code> - Dosya içeriğini görüntüle</li>
              </ul>
              <h3 class="h4 mb-2">"ls" ile biraz eğlenelim</h3>
              <p><code>ls</code> komutu muhtemelen en çok kullanılan komuttur. Bu komutla, dizin içeriğini görebilir ve çeşitli önemli dosya ve dizin niteliklerini belirleyebilirsiniz. Geçerli çalışma dizininde bulunan dosyaların ve alt dizinlerin listesini almak için <code>ls</code> komutunu girin:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls
Desktop  Documents  Music  Pictures  Public  Templates  Videos</code></pre>
              <p>Geçerli çalışma dizininin yanında, listelenecek dizini de belirtebilirsiniz:</p>
              <pre><code class="language-bash">me@linuxbox ~]$ ls /usr
bin  games  include  lib  local  sbin  share  src</code></pre>
              <p>Birden fazla dizinde belirlenebilir. Aşağıdaki örnekte, hem kullanıcının giriş dizini (<code>~</code> karakteri ile sembolize edilmiştir) hem de <code>/usr</code> dizini listeleniyor.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls ~ /usr
/home/me:
Desktop  Documents  Music  Pictures  Public  Templates  Videos

/usr:
bin  games  include  lib  local  sbin  share  src</code></pre>
              <p>Daha fazla detay için çıktının biçimini de değiştirebilirsiniz.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l
total 56
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Desktop
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Documents
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Music
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Pictures
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Public
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Templates
drwxrwxr-x 2 me me 4096 2017-10-26 17:20 Videos</code></pre>
              <p><code>-l</code> seçeneğini ekleyerek çıktı biçimini uzun format olarak değiştirdik.</p>
              <h4 class="h5 mb-2">Seçenekler ve parametreler</h4>
              <p>Bu bizi komutların nasıl çalıştığı konusunda çok önemli bir noktaya getiriyor. Komutları genellikle davranışlarını değiştiren bir veya daha fazla seçenek, ardından da bir veya daha fazla parametre izler. Yani çoğu komut şuna benzer:</p>
              <pre><code class="language-bash">command -options arguments</code></pre>
              <p>Çoğu komut, bir çizgi ile başlayan tek bir karakterden oluşan seçenekleri kullanır, örneğin <code>-l</code>. Bununla birlikte, GNU Projesi'nden olanlar da dahil olmak üzere birçok komut, iki çizgi ile başlayan bir kelimeden oluşan uzun seçenekleri de desteklemektedir. Ayrıca, birçok komut birden fazla kısa seçeneğin birbirine eklenebilmesini sağlar. Aşağıdaki örnekte, <code>ls</code> komutuna, uzun formatlı çıktı üretmek için <code>l</code> ve sonucu dosyanın değiştirilme zamanına göre sıralamak için <code>t</code> seçeneği verilmiştir.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -lt</code></pre>
              <p>Sıralamayı tersine çevirmek için <code>--reverse</code> ekleyin.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -lt --reverse</code></pre>
              <div class="row">
                <div class="col">
                  <div class="alert alert-info" role="alert">
                    <h4>Not</h4>
                    <p>Linux'taki dosya adları gibi komut seçeneklerinin de büyük/küçük harf duyarlı olduğunu unutmayın.</p>
                    <i class="icon-info-circle"></i>
                  </div>
                </div>
              </div>
              <p><code>ls</code> komutu çok sayıda olası seçeneğe sahiptir. En yaygın olanlar aşağıdaki tabloda listelenmiştir.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Seçenek</th>
                        <th scope="col">Uzun Seçenek</th>
                        <th scope="col">Açıklama</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">-a</th>
                        <td>--all</td>
                        <td>Normalde listelenmeyen dosyalar da dahil (adı nokta ile başlayan gizli dosyalar) tüm dosyaları listeler.</td>
                      </tr>
                      <tr>
                        <th scope="row">-A</th>
                        <td>--almost-all</td>
                        <td>Geçerli dizini (.) ve üst dizini (..) listelememesi dışında yukarıdaki <code>-a</code> seçeneğine benzer.</td>
                      </tr>
                      <tr>
                        <th scope="row">-d</th>
                        <td>--directory</td>
                        <td>Normalde, bir dizin belirtildiğinde, <code>ls</code> dizinin kendisini değil dizinin içeriğini listeler. Dizin içeriği yerine dizin ayrıntılarını görmek için <code>-l</code> seçeneğiyle birlikte bu seçeneği kullanın.</td>
                      </tr>
                      <tr>
                        <th scope="row">-F</th>
                        <td>--classify</td>
                        <td>Bu seçenek listelenen her ismin sonuna bir gösterge karakteri ekleyecektir. Örneğin, bir dizin için eğik çizgi (/) eklenir.</td>
                      </tr>
                      <tr>
                        <th scope="row">-h</th>
                        <td>--human-readable</td>
                        <td>Uzun formatlı listelerde, dosya boyutlarını bayt yerine insan tarafından okunabilir biçimde görüntüler.</td>
                      </tr>
                      <tr>
                        <th scope="row">-l</th>
                        <td></td>
                        <td>Sonuçları uzun formatta görüntüler.</td>
                      </tr>
                      <tr>
                        <th scope="row">-r</th>
                        <td>--reverse</td>
                        <td>Sonuçları ters sıralar. Normalde, <code>ls</code> sonuçları artan alfabetik sıraya göre görüntüler.</td>
                      </tr>
                      <tr>
                        <th scope="row">-S</th>
                        <td></td>
                        <td>Sonuçları dosya boyutuna göre sıralar.</td>
                      </tr>
                      <tr>
                        <th scope="row">-t</th>
                        <td></td>
                        <td>Değiştirme zamanına göre sıralar.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <h4 class="h5 mb-2">Uzun formata uzun bir bakış</h4>
              <p>Daha önce gördüğümüz gibi <code>-l</code> seçeneği sonuçları uzun formatta görüntüler. Bu format çok sayıda faydalı bilgi içerir. Ubuntu sisteminden <code>Examples</code> dizini:</p>
              <pre><code class="language-bash">-rw-r--r-- 1 root root 3576296  2017-04-03 11:05 Experience ubuntu.ogg
-rw-r--r-- 1 root root 1186219  2017-04-03 11:05 kubuntu-leaflet.png
-rw-r--r-- 1 root root 47584    2017-04-03 11:05 logo-Edubuntu.png
-rw-r--r-- 1 root root 44355    2017-04-03 11:05 logo-Kubuntu.png
-rw-r--r-- 1 root root 34391    2017-04-03 11:05 logo-Ubuntu.png
-rw-r--r-- 1 root root 32059    2017-04-03 11:05 oo-cd-cover.odf
-rw-r--r-- 1 root root 159744   2017-04-03 11:05 oo-derivatives.doc
-rw-r--r-- 1 root root 27837    2017-04-03 11:05 oo-maxwell.odt
-rw-r--r-- 1 root root 98816    2017-04-03 11:05 oo-trig.xls
-rw-r--r-- 1 root root 453764   2017-04-03 11:05 oo-welcome.odt
-rw-r--r-- 1 root root 358374   2017-04-03 11:05 ubuntu Sax.ogg</code></pre>
              <p>Aşağıdaki tablo bize dosyalardan biriyle ilgili farklı alanlar ve anlamlarını sunmaktadır.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Alan</th>
                        <th scope="col">Anlamı</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">-rw-r--r--</th>
                        <td>Dosyaya erişim haklarını gösterir. İlk karakter dosya türünü belirtir, çizgi normal bir dosya anlamına gelirken <code>d</code> karakteri bir dizini gösterir. Sonraki üç karakter dosya sahibi, sonraki üç dosya grubunun üyeleri ve son üçü de herkezin erişim hakları içindir.</td>
                      </tr>
                      <tr>
                        <th scope="row">1</th>
                        <td>Dosyanın sabit bağlantı sayısını gösterir. Bu bölümün ilerleyen kısımlarındaki "Sembolik Bağlantılar" ve "Sabit Bağlantılar" bölümlerine bakabilirsiniz.</td>
                      </tr>
                      <tr>
                        <th scope="row">root</th>
                        <td>Dosyanın sahibinin kullanıcı adı.</td>
                      </tr>
                      <tr>
                        <th scope="row">root</th>
                        <td>Dosyaya sahip olan grubun adı.</td>
                      </tr>
                      <tr>
                        <th scope="row">32059</th>
                        <td>Dosyanın bayt olarak boyutu.</td>
                      </tr>
                      <tr>
                        <th scope="row">2007-04-03 11:05</th>
                        <td>Dosyanın son değiştirildiği tarih ve saat.</td>
                      </tr>
                      <tr>
                        <th scope="row">oo-cd-cover.odf</th>
                        <td>Dosyanın adı.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <h3 class="h4 mb-2">"file" ile dosya türünü belirlemek</h3>
              <p>Sistemi keşfederken hangi dosyaları içerdiğini bilmek faydalı olacaktır. Bir dosyanın türünü belirlemek için <code>file</code> komutunu kullanacağız. Daha önce de anlatıldığı gibi, Linux'taki dosya adları dosya içeriğini yansıtmayabilir. <em>Picture.jpg</em> gibi bir dosya adının normalde JPEG sıkıştırılmış resim içermesi beklenirken, Linux'ta böyle olması gerekmez. <code>file</code> komutunu şu şekilde çağırabiliriz:</p>
              <pre><code class="language-bash">file filename</code></pre>
              <p><code>file</code> komutu çağırıldığında, dosya içeriğinin kısa bir açıklamasını ekrana basacaktır. Örneğin:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ file picture.jpg
picture.jpg: JPEG image data, JFIF standard 1.01</code></pre>
              <p>Birçok dosya türü vardır. Aslında, Linux gibi Unix benzeri işletim sistemlerinin ortak fikirlerden biri "her şey bir dosya" dır. Devam ettikçe, bu ifadenin ne kadar doğru olduğunu göreceğiz.</p>
              <p>Sistemimizdeki dosyaların çoğu tanıdık gelse de - örneğin MP3 ve JPEG - daha az belirgin olan ve garip görünen birkaç türde vardır.</p>
              <h3 class="h4 mb-2">Dosya içeriğini "less" ile görüntülemek</h3>
              <p><code>less</code> komutu, metin dosyalarını görüntülemek için kullanılan bir programdır. Linux sistemimizde, insan tarafından okunabilen metinler içeren birçok dosya bulunur. <code>less</code> bu metinleri incelemek için uygun bir yol sağlar.</p>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>"Text" nedir?</h4>
                    <p>Bilgisayardaki bilgileri temsil etmenin birçok yolu vardır. Tüm yöntemler, bilgi ile onu temsil etmek için kullanılacak bazı sayılar arasında ilişki tanımlamayı içerir. Sonuçta, bilgisayarlar, yalnızca sayıları anlar ve tüm veriler sayısal gösterime dönüştürülür.</p>
                    <p>Bu temsil sistemlerinden bazıları çok karmaşıktır (sıkıştırılmış video dosyaları gibi), bazıları ise oldukça basittir. En eski ve en basitlerinden biride ASCII metinlerdir. ASCII ("As-Key" olarak telaffuz edilir) "American Standard Code for Information Interchange" kısaltmasıdır. İlk olarak <em>Teletype</em> makinelerinde klavyedeki karakterleri sayılarla eşleştirmek için kullanılmış basit bir kodlama şemasıdır.</p>
                    <p>Text (Metin), karakterlerin sayılarla bire bir eşleştirilmesidir. Metnin 50 karakteri 50 veri baytına çevrilir. Metinlerin yalnızca karakter ve sayıların basit bir şekilde eşleştirilmesinden ibaret olduğunu anlamak önemlidir. <em>Microsoft Word</em> veya <em>LibreOffice Writer</em> ile oluşturulan bir döküman, kelime işlemci ile oluşturulan dökümandan farklıdır. Bu dosyalar, basit ASCII metinlerin tersine, yapı ve biçimlendirmeyi tanımlamak için kullanılan birçok metin dışı öğe içerir. Düz ASCII metin dosyaları yalnızca karakterlerin kendilerini ve sekmeler, satır başı gibi birkaç basit kontrol kodunu içerir.</p>
                    <p>Linux'ta birçok dosya metin biçiminde saklanır ve metin dosyalarıyla çalışan birçok Linux aracı bulunur. Windows bile bu formatın önemini kabul eder. İyi bilinen <em>NOTEPAD.EXE</em> programı, düz ASCII metin dosyaları için bir editördür.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
              <p>Neden metin dosyalarını incelemek isteyelim? Çünkü sistem ayarlarını içeren (konfigürasyon dosyaları olarak adlandırılan) dosyaların çoğu bu formatta saklanır ve bunları okumak sistemin nasıl çalıştığı hakkında bize fikir verir. Ek olarak, sistemin kullandığı programların bazıları (script olarak adlandırılır) bu biçimde saklanır. Daha sonraki bölümlerde, sistem ayarlarını değiştirmek ve kendi scriptlerimizi yazmak için metin dosyalarını nasıl düzenleyeceğimizi öğreneceğiz, ancak şimdilik sadece içeriklerine bakalım.</p>
              <p><code>less</code> komut bu şekilde kullanılır:</p>
              <pre><code class="language-bash">less filename</code></pre>
              <p>Başladıktan sonra, <code>less</code> programı bir metin dosyasında ileri ve geri gitmemize izin verir. Örneğin, sistemin tüm kullanıcı hesaplarını tanımlayan dosyayı incelemek için aşağıdaki komutu girin:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ less /etc/passwd</code></pre>
              <p>Dosya bir sayfadan uzunsa, aşağı ve yukarı kaydırabilirsiniz. <code>less</code>'den çıkmak için <code>q</code> tuşuna basın. Aşağıdaki tabloda, <code>less</code> tarafından kullanılan en yaygın klavye komutları listelenmiştir.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Komut</th>
                        <th scope="col">Eylem</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">Page Up veya b</th>
                        <td>Bir sayfa geri kaydır</td>
                      </tr>
                      <tr>
                        <th scope="row">Page Down veya space</th>
                        <td>Bir sayfa ileri kaydır</td>
                      </tr>
                      <tr>
                        <th scope="row">Yukarı ok</th>
                        <td>Bir satır yukarı kaydır</td>
                      </tr>
                      <tr>
                        <th scope="row">Aşağı ok</th>
                        <td>Bir satır aşağı kaydır</td>
                      </tr>
                      <tr>
                        <th scope="row">G</th>
                        <td>Metin dosyasının sonuna git</td>
                      </tr>
                      <tr>
                        <th scope="row">1G veya g</th>
                        <td>Metin dosyasının başına git</td>
                      </tr>
                      <tr>
                        <th scope="row">/characters</th>
                        <td>İleriye doğru arama yap</td>
                      </tr>
                      <tr>
                        <th scope="row">n</th>
                        <td>Bir önceki bulunan satıra geri dön</td>
                      </tr>
                      <tr>
                        <th scope="row">h</th>
                        <td>Yardım ekranını görüntüle</td>
                      </tr>
                      <tr>
                        <th scope="row">q</th>
                        <td><code>less</code>'ten çık</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>Az daha çoktur</h4>
                    <p><code>less</code> programı, <code>more</code> olarak adlandırılan daha önceki bir Unix programının geliştirilmiş halidir. <code>less</code> adı, modernist mimarların ve tasarımcıların sloganı olan "less is more" ifadesindeki bir kelime oyunudur. </p>
                    <p><code>less</code>, uzun metinlerin sayfalar halinde kolayca görüntülenmesini sağlayan programlar olan "pagers" sınıfına girer. <code>more</code> programı sadece sayfalarda ileriye gidebilse de, <code>less</code> programı hem ileri hem de geri sayfalamayı mümkün kılar ve birçok başka özelliğe de sahiptir.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
              <h3 class="h4 mb-2">Rehberli bir tur atalım</h3>
              <p>Bir Linux sistemindeki dosya sistemi düzeni, diğer Unix benzeri sistemlerde bulunanlara çok benzer. Tasarım aslında "Linux Filesystem Hierarchy Standard" adı verilen yayınlanmış bir standartta belirtilmiştir. Tüm Linux dağıtımları bu standarda tam olarak uymaz, ancak çoğu oldukça yakındır.</p>
              <p>Ardından, Linux'ün nasıl çalıştığını görmek için dosya sisteminin etrafında dolaşacağız. Bu bize navigasyon becerilerimizi uygulama şansı verecek. Keşfedeceğimiz şeylerden biri, dosyaların çoğunun insan tarafından okunabilen düz metin olduğudur. Turumuza başlamadan önce, aşağıdakileri deneyin:</p>
              <ul>
                <li><code>cd</code> ile bir dizine girin</li>
                <li>Dizin içeriğini <code>ls -l</code> ile listeleyin</li>
                <li>İlginç bir dosya görürseniz, içeriğini <code>file</code> ile belirleyin</li>
                <li>Metin gibi görünüyorsa, <code>less</code> ile görüntülemeyi deneyin</li>
                <li>Yanlışlıkla metin olmayan bir dosyayı görüntülemeye çalışırsanız ve terminal penceresi karışırsa, <code>reset</code> komutunu girerek kurtarabilirsiniz.</li>
              </ul>
              <p>Etrafta dolaşırken birşeylere bakmaktan korkmayın. Normal kullanıcılar işleri batıramazlar. Bu sistem yöneticisinin işidir! Bir komut bir şeyden şikayet ediyorsa, başka bir şeye geçin. Etrafa bakarken biraz zaman geçirin. Unutmayın, Linux'ta sır yoktur!</p>
              <p>Aşağıdaki tabloda keşfedebildiğimiz dizinlerden birkaçı listelenmektedir. Linux dağıtımımıza bağlı olarak bazı küçük farklılıklar olabilir.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Dizin</th>
                        <th scope="col">Açıklama</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">/</th>
                        <td>Kök dizini. Her şeyin başladığı yer.</td>
                      </tr>
                      <tr>
                        <th scope="row">/bin</th>
                        <td>Sistemin önyüklemesi ve çalışması için gerekli ikili (binary) dosyaları (programlar) içerir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/boot</th>
                        <td>
                          <p>Linux çekirdeğini, başlangıçtaki RAM disk görüntüsünü (önyükleme sırasında gereken sürücüler için) ve önyükleyiciyi içerir.</p>
                          <p>İlginç dosyalar:</p>
                          <ul>
                            <li><code>/boot/grub/grub.conf</code> veya <code>menu.lst</code>, önyükleme yükleyicisini yapılandırmak için kullanılır.</li>
                            <li><code>/boot/vmlinuz</code> (veya benzeri bir şey), Linux çekirdeği</li>
                          </ul>
                        </td>
                      </tr>
                      <tr>
                        <th scope="row">/dev</th>
                        <td>Aygıt düğümlerini içeren özel bir dizindir. “Her şey bir dosyadır” ifadesi aygıtlar için de geçerlidir. Çekirdeğin anladığı tüm aygıtların listesi burada tutuluyor.</td>
                      </tr>
                      <tr>
                        <th scope="row">/etc</th>
                        <td>
                          <p>Sistem genelindeki tüm yapılandırma dosyalarını içerir. Ayrıca, sistem hizmetlerinin her birini önyükleme sırasında başlatan bir kabuk komut dosyası koleksiyonu içerir. Bu dizindeki her şey okunabilir metin olmalıdır.</p>
                          <p><code>/etc</code> içindeki her şey ilginç olsa da, işte tüm zamanların favorileri:</p>
                          <ul>
                            <li><code>/etc/crontab</code>, otomatikleştirilmiş işlerin ne zaman çalışacağını tanımlayan bir dosya.</li>
                            <li><code>/etc/fstab</code>, depolama aygıtları tablosu ve bunlarla ilgili bağlantı noktaları.</li>
                            <li><code>/etc/passwd</code>, kullanıcı hesaplarının listesi.</li>
                          </ul>
                        </td>
                      </tr>
                      <tr>
                        <th scope="row">/home</th>
                        <td>Normal yapılandırmalarda, her kullanıcıya <code>/home</code> içinde bir dizin verilir. Sıradan kullanıcılar sadece kendi dizinlerinde yazma iznine sahiptir. Bu sınırlama sistemi hatalı kullanıcı faaliyetlerinden korur.</td>
                      </tr>
                      <tr>
                        <th scope="row">/lib</th>
                        <td>Çekirdek sistem programları tarafından kullanılan ve paylaşılan kütüphane dosyalarını içerir. Bunlar, Windows'taki dinamik bağlantı kütüphanelerine (DLL) benzer.</td>
                      </tr>
                      <tr>
                        <th scope="row">/lost+found</th>
                        <td>Ext4 gibi bir Linux dosya sistemi kullanan her biçimlendirilmiş bölüm veya cihaz bu dizine sahip olacaktır. Bir dosya sistemi bozulmasından kısmi kurtarma durumunda kullanılır. Sistemimizde gerçekten kötü bir şey olmadıkça, bu dizin boş kalacaktır.</td>
                      </tr>
                      <tr>
                        <th scope="row">/media</th>
                         <td>Modern Linux sistemlerinde <code>/media</code> dizini, otomatik olarak monte edilen çıkarılabilir medya (USB sürücüler, CD-ROM'lar vb.) için bağlantı noktaları içerir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/mnt</th>
                        <td>Eski Linux sistemlerinde <code>/mnt</code> dizini, manuel olarak monte edilen çıkarılabilir cihazlar için bağlantı noktaları içerir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/opt</th>
                        <td><code>/opt</code> dizini "isteğe bağlı" yazılım - daha çok sisteme kurulabilecek ticari yazılım ürünleri - kurmak için kullanılır.</td>
                      </tr>
                      <tr>
                        <th scope="row">/proc</th>
                        <td><code>/proc</code> dizini özeldir. Sabit sürücüde depolanan dosyalar gibi gerçek bir dosya sistemi değildir. Aksine, Linux çekirdeği tarafından tutulan sanal bir dosya sistemidir. İçerdiği “dosyalar” okunabilir durumdadır ve çekirdeğin içini görmemizi sağlar.</td>
                      </tr>
                      <tr>
                        <th scope="row">/root</th>
                        <td>Bu <code>root</code> hesabının giriş dizinidir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/sbin</th>
                        <td>Bu dizin "sistem" ikili (binary) dosyalarını içerir. Bunlar, genellikle süper kullanıcı için ayrılmış hayati sistem görevlerini yerine getiren programlardır.</td>
                      </tr>
                      <tr>
                        <th scope="row">/tmp</th>
                        <td><code>/tmp</code> dizini çeşitli programlar tarafından oluşturulan geçici dosyaları saklar. Bazı yapılandırmalar sistem yeniden başlatıldığında bu dizinin boşaltılmasına neden olur.</td>
                      </tr>
                      <tr>
                        <th scope="row">/usr</th>
                        <td><code>/usr</code> dizin ağacı büyük olasılıkla Linux sisteminin en büyüğüdür. Tüm programları ve normal kullanıcılar tarafından kullanılan destek dosyalarını içerir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/usr/bin</th>
                        <td><code>/usr/bin</code>, Linux dağıtımı tarafından yüklenen çalıştırılabilir programları içerir. Bu dizinin binlerce programa sahip olması olağandışı değildir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/usr/lib</th>
                        <td><code>/usr/bin</code> içindeki programlar için paylaşılan kütüphaneler.</td>
                      </tr>
                      <tr>
                        <th scope="row">/usr/local</th>
                        <td><code>/usr/local</code> ağacı, dağıtıma dahil edilmeyen ancak sistem geleninde kullanıma yönelik programların kurulu olduğu yerdir. Kaynak koddan derlenen programlar normalde <code>/usr/local/bin</code> dizinine kurulur. Yeni kurulan bir Linux sisteminde, bu ağaç vardır, ancak sistem yöneticisi içine bir şey koyana kadar boş kalır.</td>
                      </tr>
                      <tr>
                        <th scope="row">/usr/sbin</th>
                        <td>Daha fazla sistem yönetimi programı içerir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/usr/share</th>
                        <td><code>/usr/bin</code> içindeki programlar tarafından kullanılan tüm paylaşılan verileri (varsayılan yapılandırma dosyaları, simgeler, ekran arka planları, ses dosyaları vb.) içerir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/usr/share/doc</th>
                        <td>Sistemde kurulu paketlerin çoğu bir tür dokümantasyon içerecektir. <code>/usr/share/doc</code> içinde, paketlere göre organize edilmiş dokümantasyon dosyalarını bulacağız.</td>
                      </tr>
                      <tr>
                        <th scope="row">/var</th>
                        <td><code>/tmp</code> ve <code>/home</code> dışında, şu ana kadar baktığımız dizinler nispeten statik kalır, yani içerikleri değişmez. <code>/var</code> dizin ağacı, değişmesi muhtemel verilerin - çeşitli veritabanları, biriktirme (spool) dosyaları, kullanıcı e-postaları vb. - saklandığı yerdir.</td>
                      </tr>
                      <tr>
                        <th scope="row">/var/log</th>
                        <td>Günlük dosyalarını ve çeşitli sistem faaliyet kayıtlarını içerir. Bunlar önemlidir ve zaman zaman izlenmelidir. En faydalı olanlar <code>/var/log/messages</code> ve <code>/var/log/syslog</code>'dur. Güvenlik nedeniyle bazı sistemlerde sadece süper kullanıcı günlük dosyalarını görüntüleyebilir.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <h3 class="h4 mb-2">Sembolik bağlantılar</h3>
              <p>Etrafınıza bakarken şöyle bir dizin listesi (örneğin, <code>/lib</code>) görmeniz muhtemeldir:</p>
              <pre><code class="language-bash">lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so</code></pre>
              <p>Girdinin ilk harfinin "l" olduğuna ve iki dosya adına sahip olduğuna dikkat edin. Bu, sembolik link (soft link veya symlink olarak da bilinir) adı verilen özel bir dosya türüdür. Unix benzeri çoğu sistemde, birden fazla isimle referans verilen bir dosyaya sahip olmak mümkündür. Bunun değeri ilk bakışta görünmese de, gerçekten faydalı bir özellik.</p>
              <p>Şu senaryoyu hayal edin: Bir program "foo" adlı bir dosyada bulunan bir tür paylaşımlı kaynağın kullanılmasını gerektirir, ancak sıkça sürümü değişmektedir. Sürüm numarasını dosya adına eklemek mantıklı olacaktır, böylelikle yönetici veya ilgili diğer taraflar hangi sürümün kurulu olduğunu görebilir. Bu yeni bir soruna neden olur. Paylaşılan kaynağın adını değiştirirsek, onu kullanabilecek her programı izlemeli ve kaynağın her yeni sürümü yüklendiğinde yeni bir kaynak adı arayacak şekilde değiştirmeliyiz. Bu kulağa hiçte eğlenceli gelmiyor.</p>
              <p>İşte sembolik bağlantıların günü kurtardığı yer. Diyelim ki "foo-2.6" dosya adını taşıyan "foo" nun 2.6 sürümünü yüklediğimizi ve sonra "foo-2.6" ya işaret eden basitçe "foo" olarak adlandırılan sembolik bir bağlantı oluşturduğumuzu varsayalım. Bu, bir program “foo” dosyasını açtığında, aslında “foo-2.6” dosyasını açıyor demektir. Şimdi herkes mutlu. "foo" yu kullanan programlar onu bulabilir ve gerçekte hangi versiyonun kurulu olduğunu görebiliriz. "foo-2.7" ye yükseltme zamanı geldiğinde dosyayı sistemimize ekledik, "foo" sembolik bağlantısını silip yeni sürüme işaret eden yeni bir tane oluşturduk. Bu yalnızca sürüm yükseltme sorununu çözmez, aynı zamanda her iki sürümü de makinemizde tutmamızı sağlar. "foo-2.7" de bir hata olduğunu (ah bu geliştiriciler!) ve eski sürüme geri dönmeniz gerektiğini hayal edin. Yine, sadece yeni sürüme işaret eden sembolik bağlantıyı siler ve eski sürüme işaret eden yeni bir sembolik bağlantı oluştururuz.</p>
              <p>Bu bölümün başındaki dizin listesi (Fedora sisteminin <code>/lib</code> dizininden) <code>libc.so.6</code> adlı sembolik bağlantıyı gösterir. Bu, <code>libc.so.6</code>'yı arayan programların aslında <code>libc-2.6.so</code> dosyasını alacağı anlamına gelir. Bir sonraki bölümde sembolik bağların nasıl oluşturulacağını öğreneceğiz.</p>
              <h3 class="h4 mb-2">Sabit bağlantılar</h3>
              <p>Bağlantılar konusunda, sabit bağlantı adı verilen ikinci bir bağlantı türü olduğunu belirtmemiz gerekir. Sabit bağlantılar da dosyaların birden fazla ada sahip olmasına izin verir, ancak bunu farklı bir şekilde yaparlar. Bir sonraki bölümde sembolik ve sabit bağlantılar arasındaki farklar hakkında daha fazla konuşacağız.</p>
            </section>
            <!-- / exploring the system -->

            <!-- manipulating files and directories -->
            <section id="section-4">
              <h2 class="section-title-2 mb-2">Dosya ve Dizinleri Yönetmek <a data-scroll="" href="#section-4" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>Artık gerçek bir iş için hazırsınız! Bu bölümde aşağıdaki komutları öğreneceksiniz:</p>
              <ul>
                <li><code>cp</code> - Dosya ve dizinleri kopyala</li>
                <li><code>mv</code> - Dosyaları ve dizinleri taşı/yeniden adlandır</li>
                <li><code>mkdir</code> - Dizin oluştur</li>
                <li><code>rm</code> - Dosyaları ve dizinleri kaldır</li>
                <li><code>ln</code> - Sabit ve sembolik bağlantılar oluştur</li>
              </ul>
              <p>Bu beş komut en sık kullanılan Linux komutları arasındadır. Hem dosyaları hem de dizinleri düzenlemek için kullanılırlar.</p>
              <p>Açık olmak gerekirse, bu komutların yerine getirdiği görevlerin bir kısmı grafik dosya yöneticisi ile daha kolay yapılabilir. Dosya yöneticisi ile bir dosyayı bir dizinden diğerine sürükleyip bırakabilir, dosyaları kesip yapıştırabilir ve silebiliriz vb. Peki neden bu eski komut satırı programlarını kullanıyoruz?</p>
              <p>Cevap güç ve esnekliktir. Grafik dosya yöneticisi ile basit dosya manipülasyonları yapmak kolay olmakla birlikte, komut satırı programlarıyla karmaşık işler daha kolay olabilir. Örneğin, yalnızca hedef dizinde bulunmayan veya hedef dizindeki sürümlerden daha yeni olan tüm HTML dosyalarını bir dizinden diğerine nasıl kopyalayabiliriz? Dosya yöneticisi ile oldukça zor ama komut satırı ile oldukça kolaydır.</p>
              <pre><code class="language-bash">cp -u *.html destination</code></pre>
              <h3 class="h4 mb-2">Joker karakterler</h3>
              <p>Komutlarımızı kullanmaya başlamadan önce, bu komutları bu kadar güçlü kılan bir kabuk özelliği hakkında konuşmamız gerekiyor. Kabuk dosya adlarını çok fazla kullandığından, dosya adlarını hızlı bir şekilde belirlememize yardımcı olacak özel karakterler sunar. Bu özel karakterlere joker karakterler denir. Joker karakterleri kullanmak (aynı zamanda globbing olarak da bilinir) karakter kalıplarını temel alan dosya adlarını seçmemize izin verir. Aşağıdaki tablo joker karakterleri ve neyi seçtiklerini listeler.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Joker Karakter</th>
                        <th scope="col">Anlamı</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">*</th>
                        <td>Herhangi bir karakterle eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">?</th>
                        <td>Herhangi bir tek karakterle eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">[characters]</th>
                        <td>Karakter setinin üyesi olan herhangi bir karakterle eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">[!characters]</th>
                        <td>Karakter setinin üyesi olmayan herhangi bir karakterle eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">[[:class:]]</th>
                        <td>Belirtilen sınıfın üyesi olan herhangi bir karakterle eşleşir</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>Aşağıdaki tablo en yaygın kullanılan karakter sınıflarını listeler.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Karakter Sınıfı</th>
                        <th scope="col">Anlamı</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">[:alnum:]</th>
                        <td>Alfanümerik herhangi bir karakterle eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">[:alpha:]</th>
                        <td>Herhangi bir alfabetik karakterle eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">[:digit:]</th>
                        <td>Rakamlarla eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">[:lower:]</th>
                        <td>Küçük harflerle eşleşir</td>
                      </tr>
                      <tr>
                        <th scope="row">[:upper:]</th>
                        <td>Büyük harflerle eşleşir</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>Joker karakterleri kullanmak, dosya adları için karmaşık seçim kriterleri oluşturmayı mümkün kılar. Aşağıdaki tablo, bazı şablon örneklerini ve ne ile eşleştiklerini göstermektedir.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Şablon</th>
                        <th scope="col">Eşleşme</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">*</th>
                        <td>Tüm dosyalar</td>
                      </tr>
                      <tr>
                        <th scope="row">g*</th>
                        <td>"g" ile başlayan herhangi bir dosya</td>
                      </tr>
                      <tr>
                        <th scope="row">b*.txt</th>
                        <td>"b" ile başlayan, ardından herhangi bir karakterle devam eden ve ".txt" ile biten herhangi bir dosya</td>
                      </tr>
                      <tr>
                        <th scope="row">Data???</th>
                        <td>"Data" ile başlayan ve ardından tam üç karakterle devam eden herhangi bir dosya</td>
                      </tr>
                      <tr>
                        <th scope="row">[abc]*</th>
                        <td>"a", a "b" veya a "c" ile başlayan herhangi bir dosya</td>
                      </tr>
                      <tr>
                        <th scope="row">BACKUP.[0-9][0-9][0-9]</th>
                        <td>"BACKUP." İle başlayan ve ardından tam olarak üç rakamla devam eden herhangi bir dosya</td>
                      </tr>
                      <tr>
                        <th scope="row">[[:upper:]]*</th>
                        <td>Büyük harfle başlayan herhangi bir dosya</td>
                      </tr>
                      <tr>
                        <th scope="row">[![:digit:]]*</th>
                        <td>Rakamla başlamayan herhangi bir dosya</td>
                      </tr>
                      <tr>
                        <th scope="row">*[[:lower:]123]</th>
                        <td>Küçük harf veya "1", "2" veya "3" rakamlarıyla biten herhangi bir dosya</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>Joker karakterler, dosya adlarını argüman olarak kabul eden herhangi bir komutla beraber kullanılabilir, ancak "Dünyayı Kabuk Olarak Görmek" başlıklı bölümde daha detaylı inceleyeceğiz.</p>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>Karakter aralıkları</h4>
                    <p>Başka bir Unix benzeri ortamdan geliyorsanız veya bu konuda kitap okuyorsanız, <code>[A-Z]</code> ve <code>[a-z]</code> karakter aralığı notasyonlarıyla karşılaşmış olabilirsiniz. Bunlar geleneksel Unix notasyonlarıdır ve Linux'un eski sürümlerinde de çalışır. Hala kullanılabilirler, ancak dikkatli olmalısınız çünkü doğru bir şekilde yapılandırılmadıkça beklenen sonuçları vermeyeceklerdir. Şimdilik kullanmaktan kaçınmalı ve bunun yerine karakter sınıflarını kullanmalısınız.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
              <h4 class="h5 mb-2">Joker karakterler GUI'de çalışabilir</h4>
              <p>Joker karakterler, yalnızca komut satırında çok sık kullanıldığı için değil, aynı zamanda bazı grafiksel dosya yöneticileri tarafından da desteklendikleri için değerlidir.</p>
              <ul>
                <li><em>Nautilus</em>'ta (GNOME'un dosya yöneticisi), "Edit/Select Pattern" menüsünü kullanarak dosyaları seçebilirsiniz. Joker karakterler ile şablonunuzu girdiğinizde, görüntülediğiniz dizinde eşleşen dosyalar seçim için vurgulanacaktır.</li>
                <li><em>Dolphin</em> ve <em>Konqueror</em>'un bazı sürümlerinde (KDE'nin dosya yöneticileri) joker karakterleri doğrudan konum çubuğuna girebilirsiniz. Örneğin, <code>/usr/bin</code> dizininde küçük harfle "u" ile başlayan tüm dosyaları görmek istiyorsanız, konum çubuğuna "/usr/bin/u*" girin.</li>
              </ul>
              <p>Başlangıçta komut satırı arayüzünde bulunan birçok fikir grafik arayüzüne de uygulanır. Linux masaüstünü bu kadar güçlü yapan şeylerden biride budur.</p>
              <h3 class="h4 mb-2">mkdir - Dizin oluşturmak</h3>
              <p><code>mkdir</code> komutu, dizin oluşturmak için kullanılır. Şu şekilde çalışır:</p>
              <pre><code class="language-bash">mkdir directory...</code></pre>
              <p><strong>Notasyona ilişkin bir not:</strong> Komut tanımındaki argümanı takip eden üç nokta (yukarıdaki gibi), argümanın tekrarlanabileceği anlamına gelir, bu nedenle aşağıdaki komut:</p>
              <pre><code class="language-bash">mkdir dir1</code></pre>
              <p><code>dir1</code> adında tek bir dizin oluştururken;</p>
              <pre><code class="language-bash">mkdir dir1 dir2 dir3</code></pre>
              <p><code>dir1</code>, <code>dir2</code> ve <code>dir3</code> adlı üç dizin oluşturur.</p>
              <h3 class="h4 mb-2">cp - Dosya ve dizinleri kopyalamak</h3>
              <p><code>cp</code> komutu dosyaları veya dizinleri kopyalar. İki farklı şekilde kullanılabilir:</p>
              <pre><code class="language-bash">cp item1 item2</code></pre>
              <p>tek bir dosya veya dizin olan <code>item1</code>'i dosya veya dizin olan <code>item2</code>'ye kopyalar ve aşağıdaki:</p>
              <pre><code class="language-bash">cp item... directory</code></pre>
              <p>birden fazla öğeyi (dosya veya dizin) bir dizine kopyalar.</p>
              <h4 class="h5 mb-2">Faydalı seçenekler ve örnekler</h4>
              <p>Aşağıdaki tablo <code>cp</code> için yaygın olarak kullanılan seçeneklerin bazılarını listeler.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Seçenek</th>
                        <th scope="col">Uzun Seçenek</th>
                        <th scope="col">Açıklama</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">-a</th>
                        <td>--archive</td>
                        <td>Dosya ve dizinleri tüm nitelikleri (sahiplik ve izinler dahil) ile beraber kopyalar. Normalde kopya, kopyayı gerçekleştiren kullanıcının varsayılan niteliklerini alır. "İzinler" bölümünde dosya izinlerine göz atacağız.</td>
                      </tr>
                      <tr>
                        <th scope="row">-i</th>
                        <td>--interactive</td>
                        <td>Mevcut bir dosyanın üzerine yazmadan önce kullanıcıdan onay ister. Bu seçenek belirtilmezse, <code>cp</code> sessizce (hiçbir uyarı olmadan) dosyaların üzerine yazacaktır.</td>
                      </tr>
                      <tr>
                        <th scope="row">-r</th>
                        <td>--recursive</td>
                        <td>Dizinleri ve içeriklerini rekürsif kopyalar. Dizinleri kopyalarken bu seçenek (veya -a seçeneği) gereklidir.</td>
                      </tr>
                      <tr>
                        <th scope="row">-u</th>
                        <td>--update</td>
                        <td>Dosyaları bir dizinden diğerine kopyalarken, hedef dizinde olmayan veya varolan ilgili dosyalardan daha yeni olan dosyaları kopyalar. Çok sayıda dosya kopyalanırken, kopyalanması gerekmeyen dosyaları atladığı için kullanışlıdır.</td>
                      </tr>
                      <tr>
                        <th scope="row">-v</th>
                        <td>--verbose</td>
                        <td>Kopyalama yapılırken bilgi mesajlarını görüntüler.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <h4 class="h5 mb-2"><strong>cp</strong> örnekleri</h4>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col" class="col-lg-4">Komut</th>
                        <th scope="col" class="col-lg-8">Sonuçlar</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">cp file1 file2</th>
                        <td><em>file1</em>'i, <em>file2</em>'ye kopyalar. <strong>Eğer <em>file2</em> mevcutsa, <em>file1</em>'in içeriği <em>file2</em>'nin üzerine yazılır.</strong> <em>file2</em> mevcut değilse, oluşturulur.</td>
                      </tr>
                      <tr>
                        <th scope="row">cp -i file1 file2</th>
                        <td>Önceki komutla aynıdır, ancak <em>file2</em> mevcutsa, üzerine yazılmadan önce kullanıcı uyarılır.</td>
                      </tr>
                      <tr>
                        <th scope="row">cp file1 file2 dir1</th>
                        <td><em>file1</em> ve <em>file2</em>'yi <em>dir1</em> dizinine kopyalar. <em>dir1</em> dizini mevcut olmalıdır.</td>
                      </tr>
                      <tr>
                        <th scope="row">cp dir1/* dir2</th>
                        <td>Joker karakter kullanarak, <em>dir1</em> içindeki tüm dosyaları <em>dir2</em> dizinine kopyalar. <em>dir2</em> dizini mevcut olmalıdır.</td>
                      </tr>
                      <tr>
                        <th scope="row">cp -r dir1 dir2</th>
                        <td><em>dir1</em> dizininin içeriğini <em>dir2</em> dizinine kopyalar. Eğer <em>dir2</em> dizini mevcut değilse, yaratılır ve kopyaladıktan sonra, <em>dir1</em> dizini ile aynı içeriğe sahip olacaktır. Eğer <em>dir2</em> dizini mevcutsa, <em>dir1</em> dizini (ve içeriği) <em>dir2</em>'ye kopyalanır.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <h3 class="h4 mb-2">mv - Dosyaları taşımak ve yeniden adlandırmak</h3>
              <p><code>mv</code> komutu, nasıl kullanıldığına bağlı olarak hem dosya taşıma hem de yeniden adlandırma işlemini gerçekleştirir. Her iki durumda da, işlemden sonra orjinal dosya artık mevcut değildir. <code>mv</code> aşağıda gösterildiği gibi <code>cp</code> ile aynı şekilde kullanılır:</p>
              <pre><code class="language-bash">mv item1 item2</code></pre>
              <p>dosya veya dizini <code>item1</code>'den <code>item2</code>'ye taşımak veya yeniden adlandırmak için veya:</p>
              <pre><code class="language-bash">mv item... directory</code></pre>
              <p>bir veya daha fazla öğeyi bir dizinden diğerine taşımak için.</p>
              <h4 class="h5 mb-2">Faydalı seçenekler ve örnekler</h4>
              <p><code>mv</code>, aşağıdaki tabloda açıklanan <code>cp</code> ile benzer seçeneklerin çoğunu paylaşır.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Seçenek</th>
                        <th scope="col">Uzun Seçenek</th>
                        <th scope="col">Açıklama</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">-i</th>
                        <td>--interactive</td>
                        <td>Mevcut bir dosyanın üzerine yazmadan önce kullanıcıdan onay ister. Bu seçenek belirtilmezse, <code>mv</code> sessizce (hiçbir uyarı olmadan) dosyaların üzerine yazacaktır.</td>
                      </tr>
                      <tr>
                        <th scope="row">-u</th>
                        <td>--update</td>
                        <td>Dosyaları bir dizinden diğerine taşırken, hedef dizinde olmayan veya varolan ilgili dosyalardan daha yeni olan dosyaları taşır.</td>
                      </tr>
                      <tr>
                        <th scope="row">-v</th>
                        <td>--verbose</td>
                        <td>Dosyalar taşınırken bilgi mesajlarını görüntüler.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>Aşağıdaki tablo, <code>mv</code> kullanımına ilişkin bazı örnekler sunmaktadır.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col" class="col-lg-4">Komut</th>
                        <th scope="col" class="col-lg-8">Sonuçlar</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">mv file1 file2</th>
                        <td><em>file1</em>'i, <em>file2</em>'ye taşır. <strong>Eğer <em>file2</em> mevcutsa, <em>file1</em>'in içeriği <em>file2</em>'nin üzerine yazılır.</strong> <em>file2</em> mevcut değilse, oluşturulur. Her iki durumda da, <em>file1</em> silinecektir.</td>
                      </tr>
                      <tr>
                        <th scope="row">mv -i file1 file2</th>
                        <td>Önceki komutla aynıdır, ancak <em>file2</em> mevcutsa, üzerine yazılmadan önce kullanıcı uyarılır.</td>
                      </tr>
                      <tr>
                        <th scope="row">mv file1 file2 dir1</th>
                        <td><em>file1</em> ve <em>file2</em>'yi <em>dir1</em> dizinine taşır. <em>dir1</em> dizini mevcut olmalıdır.</td>
                      </tr>
                      <tr>
                        <th scope="row">mv dir1 dir2</th>
                        <td>Eğer <em>dir2</em> dizini mevcut değilse, <em>dir2</em> dizinini yaratır, <em>dir1</em> dizininin içeriğini <em>dir2</em> içine taşır ve <em>dir1</em> dizinini siler. Eğer <em>dir2</em> dizini mevcutsa, <em>dir1</em> dizinini (ve içeriğini) <em>dir2</em> dizinine taşır.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <h3 class="h4 mb-2">rm - Dosya ve dizinleri kaldırmak</h3>
              <p><code>rm</code> komutu, aşağıda gösterildiği gibi dosyaları ve dizinleri kaldırmak (silmek) için kullanılır:</p>
              <pre><code class="language-bash">rm item...</code></pre>
              <p><code>item</code> bir veya daha fazla dosya veya dizindir.</p>
              <h4 class="h5 mb-2">Faydalı seçenekler ve örnekler</h4>
              <p><p>Aşağıdaki tablo <code>rm</code> için yaygın olarak kullanılan seçeneklerin bazılarını listeler.</p></p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col">Seçenek</th>
                        <th scope="col">Uzun Seçenek</th>
                        <th scope="col">Açıklama</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">-i</th>
                        <td>--interactive</td>
                        <td>Mevcut bir dosyayı silmeden önce kullanıcıdan onay ister. Bu seçenek belirtilmezse, <code>rm</code> sessizce (hiçbir uyarı olmadan) dosyaları silecektir.</td>
                      </tr>
                      <tr>
                        <th scope="row">-r</th>
                        <td>--recursive</td>
                        <td>Dizinleri ve içeriklerini rekürsif siler. Bu seçenek, silinen bir dizinin alt dizinleri varsa, onları da silmek anlamına gelir. Bir dizini komple silmek için bu seçenek belirtilmelidir.</td>
                      </tr>
                      <tr>
                        <th scope="row">-f</th>
                        <td>--force</td>
                        <td>Var olmayan dosyaları yoksay ve kullanıcıdan onay isteme. Bu <code>--interactive</code> seçeneğini geçersiz kılar.</td>
                      </tr>
                      <tr>
                        <th scope="row">-v</th>
                        <td>--verbose</td>
                        <td>Dosyalar silinirken bilgi mesajlarını görüntüler.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>Aşağıdaki tablo, <code>rm</code> kullanımına ilişkin bazı örnekler sunmaktadır.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col" class="col-lg-4">Komut</th>
                        <th scope="col" class="col-lg-8">Sonuçlar</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">rm file1</th>
                        <td><em>file1</em>'i sessizce siler.</td>
                      </tr>
                      <tr>
                        <th scope="row">rm -i file1</th>
                        <td>Silme işlemi yapılmadan önce kullanıcıdan onay istenmesi dışında önceki komutla aynıdır.</td>
                      </tr>
                      <tr>
                        <th scope="row">rm -r file1 dir1</th>
                        <td><em>file1</em>, <em>dir1</em> ve içeriğini siler.</td>
                      </tr>
                      <tr>
                        <th scope="row">rm -rf file1 dir1</th>
                        <td>Önceki komutla aynıdır, ancak <em>file1</em> veya <em>dir1</em> yoksa, <em>rm</em> sessizce devam eder.</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4><strong>rm</strong> kullanırken dikkatli olun!</h4>
                    <p>Linux gibi Unix benzeri işletim sistemlerinde geri alma komutu yoktur. <code>rm</code> ile bir şey sildiğinizde, yokolur. Linux zeki olduğunuzu ve ne yaptığınızı bildiğinizi varsayar.</p>
                    <p>Joker karakterleri kullanırken özellikle dikkatli olun. Bu klasik örneği düşünün. Bir dizindeki HTML uzantılı dosyaları silmek istediğinizi varsayalım:</p>
                    <pre><code class="language-bash">rm *.html</code></pre>
                    <p>Bu ifade doğru, ancak yanlışlıkla <code>*</code> ve <code>.html</code> arasına bir boşluk koyarsanız:</p>
                    <pre><code class="language-bash">rm * .html</code></pre>
                    <p><code>rm</code> komutu dizindeki tüm dosyaları siler ve daha sonra <code>.html</code> adında dosya bulamadığı için şikayet eder.</p>
                    <p><strong>İşte size yararlı bir ipucu:</strong> <code>rm</code> ile joker karakter kullandığınızda (yazımınızı dikkatlice kontrol etmenin yanı sıra!), önce <code>ls</code> ile test edin. Bu, silinecek dosyaları görmenizi sağlayacaktır. Ardından komutu geri çağırmak için yukarı ok tuşuna basın ve <code>ls</code>'yi <code>rm</code> ile değiştirin.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
              <h3 class="h4 mb-2">ln - Bağlantı oluşturmak</h3>
              <p><code>ln</code> komutu, sabit veya sembolik bağlantılar oluşturmak için kullanılır. Aşağıdaki sabit bir bağlantı oluşturur:</p>
              <pre><code class="language-bash">ln file link</code></pre>
              <p>ve aşağıdaki sembolik bir bağlantı oluşturur:</p>
              <pre><code class="language-bash">ln -s item link</code></pre>
              <p><code>item</code> ifadesi bir dosya veya bir dizindir.</p>
              <h4 class="h5 mb-2">Sabit bağlantılar</h4>
              <p>Sabit bağlantılar - daha modern olan sembolik bağlantılara kıyasla - bağlantı oluşturmanın orjinal Unix yoludur. Varsayılan olarak, her dosyanın dosyaya adını veren tek bir sabit bağlantısı vardır. Sabit bağlantı oluşturduğumuzda,  dosya için ek bir dizin girişi oluştururuz. Sabit bağlantıların iki önemli sınırlaması vardır:</p>
              <ol>
                <li>Sabit bağlantı, kendi dosya sisteminin dışındaki bir dosyaya başvuruda bulunamaz (Sabit bağlantı ile dosya aynı disk bölümünde olmalıdır).</li>
                <li>Bir dizin için sabit bağlantı oluşturulamaz.</li>
              </ol>
              <p>Sabit bağlantı dosyanın kendisinden ayırt edilemez. Sembolik bağlantıdan farklı olarak, sabit bağlantı içeren bir dizini listelediğimizde bağlantı hakkında herhangi bir özel işaret göremeyiz. Bir sabit bağlantı silindiğinde, bağlantı kaldırılır ancak dosyanın tüm bağlantıları silinene kadar dosyanın içeriği varolmaya devam eder (yani disk alanı iade edilmez).</p>
              <p>Sabit bağlantıların farkında olmak önemlidir, çünkü zaman zaman onlarla karşılaşabilirsiniz, ancak modern uygulama daha sonra ele alacağımız sembolik bağlantıları tercih eder.</p>
              <h4 class="h5 mb-2">Sembolik bağlantılar</h4>
              <p>Sabit bağlantının sınırlarının üstesinden gelmek için sembolik bağlantılar oluşturulmuştur. Sembolik bağlantılar, başvurulan dosya veya dizine bir metin işaretçisi içeren özel bir dosya türü oluşturarak çalışır. Bu bakımdan, Windows kısayolları ile aynı şekilde çalışırlar.</p>
              <p>Sembolik bağlantının işaret ettiği dosya ve sembolik bağlantının kendisi büyük ölçüde birbirinden ayırt edilemez. Örneğin, sembolik linke bir şey yazarsak, başvurulan dosyaya yazılır. Ancak sembolik bir bağlantıyı sildiğimizde, dosyanın kendisi değil yalnızca bağlantı silinir. Dosya sembolik bağlantıdan önce silinirse, bağlantı var olmaya devam edecek fakat hiçbir şeye işaret etmeyecektir. Bu durumda, bağlantının koptuğu söylenir. Birçok uygulamada <code>ls</code> komutu, kırık bağlantıları ortaya çıkarmak için kırmızı gibi ayırt edici bir renkte görüntüler.</p>
              <p>Bağlantı kavramı kafa karıştırıcı görünebilir, ancak buna fazla takılmayın. Tüm bunları deneyeceğiz ve umarım herşey netleşecek.</p>
              <h3 class="h4 mb-2">Bir oyun alanı oluşturalım</h3>
              <p>Bazı gerçek dosya manipülasyonları yapacağımızdan komutlarla "oynamak" için güvenli bir alan oluşturalım. Öncelikle çalışabileceğimiz bir dizine ihtiyacımız var. <code>home</code> dizini altında bir tane oluşturacağız ve buna <code>playground</code> diyeceğiz.</p>
              <h4 class="h5 mb-2">Dizin oluşturmak</h4>
              <p><code>mkdir</code> komutu dizin oluşturmak için kullanılır. <code>playground</code> dizinimizi oluşturmak için önce <code>home</code> dizininde olduğumuza emin olacağız, sonra yeni dizini oluşturacağız.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cd
[me@linuxbox ~]$ mkdir playground</code></pre>
              <p>Oyun alanımızı biraz daha ilginç hale getirmek için, <code>dir1</code> ve <code>dir2</code> adında birkaç dizin oluşturalım. Bunu yapmak için geçerli çalışma dizinimizi <code>playground</code> olarak değiştireceğiz ve başka bir <code>mkdir</code> kullanacağız.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cd playground
[me@linuxbox playground]$ mkdir dir1 dir2</code></pre>
              <p><code>mkdir</code> komutunun her iki dizini de tek bir komutla oluşturduğuna dikkat edin.</p>
              <h4 class="h5 mb-2">Dosyaları kopyalamak</h4>
              <p>Ardından oyun alanımıza bazı veriler girelim. Bunu bir dosyayı kopyalayarak yapacağız. <code>cp</code> komutunu kullanarak <code>/etc</code> dizinindeki <code>passwd</code> dosyasını geçerli çalışma dizinine kopyalayacağız.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ cp /etc/passwd .</code></pre>
              <p>Geçerli çalışma dizini için kısayol kullanıldığına (.) dikkat edin. Şimdi <code>ls</code> komutunu çalıştırırsak, dosyamızı göreceğiz.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ls -l
total 12
drwxrwxr-x 2 me me 4096 2018-01-10 16:40 dir1
drwxrwxr-x 2 me me 4096 2018-01-10 16:40 dir2
-rw-r--r-- 1 me me 1650 2018-01-10 16:07 passwd</code></pre>
              <p>Şimdi, <code>-v</code> seçeneğini (verbose) kullanarak kopyalamayı tekrarlayalım.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ cp -v /etc/passwd .
`/etc/passwd' -> `./passwd'</code></pre>
              <p><code>cp</code> komutu kopyalamayı tekrar gerçekleştirdi, ancak bu kez hangi işlemi gerçekleştirdiğini belirten kısa bir mesaj görüntülendi. <code>cp</code>'nin ilk kopyalamayı hiçbir uyarı yapmadan gerçekleştirdiğine dikkat edin. Yine, bu ne yaptığınızı bildiğinizin varsayıldığı bir durumdur. Bir uyarı almak için <code>-i</code> (interactive) seçeneğini dahil edeceğiz.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ cp -i /etc/passwd .
cp: overwrite `./passwd'?</code></pre>
              <p>Bilgi istemine <code>y</code> girerek cevap vermek dosyanın üzerine yazılmasına neden olur, başka bir karakter (örneğin, <code>n</code>) kopyalamayı iptal eder.</p>
              <h4 class="h5 mb-2">Dosyaları taşımak ve yeniden adlandırmak</h4>
              <p><code>passwd</code> adı çok eğlenceli görünmüyor ve bu bir oyun alanı, o yüzden hadi başka bir şeyle değiştirelim.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ mv passwd fun</code></pre>
              <p>Yeniden adlandırılan dosyamızı dizinler arasında taşıyarak ve tekrar geri getirerek biraz daha eğlenelim. Önce <code>dir1</code> dizinine taşıyalım:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ mv fun dir1</code></pre>
              <p>Ardından <code>dir1</code>'den <code>dir2</code>'ye taşıyalım:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ mv dir1/fun dir2</code></pre>
              <p>Son olarak, geçerli çalışma dizinine geri döndürelim:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ mv dir2/fun .</code></pre>
              <p>Şimdi, <code>mv</code>'nin dizinler üzerindeki etkisini görelim. Önce veri dosyamızı tekrar <code>dir1</code>'e taşıyalım:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ mv fun dir1</code></pre>
              <p>Daha sonra <code>dir1</code>'i <code>dir2</code>'ye taşıyalım ve <code>ls</code> ile doğrulayalım:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ mv dir1 dir2
[me@linuxbox playground]$ ls -l dir2
total 4
drwxrwxr-x 2 me me 4096 2018-01-11 06:06 dir1
[me@linuxbox playground]$ ls -l dir2/dir1
total 4
-rw-r--r-- 1 me me 1650 2018-01-10 16:33 fun</code></pre>
              <p><code>dir2</code> zaten var olduğundan, <code>mv</code> komutu <code>dir1</code>'i <code>dir2</code>'ye taşır. Eğer <code>dir2</code> var olmasaydı, <code>dir1</code>'i' <code>dir2</code> olarak değiştirecekti. Son olarak, her şeyi eski yerine koyalım.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ mv dir2/dir1 .
[me@linuxbox playground]$ mv dir1/fun .</code></pre>
              <h4 class="h5 mb-2">Sabit bağlantı oluşturmak</h4>
              <p>Öncelikle veri dosyamız için sabit bağlantılar oluşturalım:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ln fun fun-hard
[me@linuxbox playground]$ ln fun dir1/fun-hard
[me@linuxbox playground]$ ln fun dir2/fun-hard</code></pre>
              <p>Şimdi <code>fun</code> dosyasının 4 örneğine sahibiz. <code>playground</code> dizinine bir göz atalım.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ls -l
total 16
drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir1
drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir2
-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard</code></pre>
              <p>Dikkatinizi çekmek istediğimiz şey, hem <code>fun</code> hem de <code>fun-hard</code> satırlarında yer alan ikinci sütunların, şu anda dosya için varolan sabit bağlantı sayısını (4) göstermesidir. Bir dosyanın her zaman en az bir bağlantıya sahip olacağını unutmayın; çünkü dosyanın adı bir bağlantı tarafından oluşturulur. Peki, <code>fun</code> ve <code>fun-hard</code>'ın aslında aynı dosya olduğunu nasıl biliyoruz? <code>fun</code> ve <code>fun-hard</code>'ın aynı boyutta olduğunu görebilsek de emin olamayız. Bu sorunu çözmek için biraz daha derine inmek zorunda kalacağız.</p>
              <p>Sabit bağlantılar hakkında düşünürken, dosyaların iki bölümden oluştuğunu hayal etmek faydalı olacaktır.</p>
              <ol>
                <li>Dosyanın içeriğini içeren veri bölümü.</li>
                <li>Dosyanın ismini taşıyan isim bölümü.</li>
              </ol>
              <p>Sabit bağlantılar oluşturduğumuzda, aslında hepsi aynı veri bölümüne başvuran ek ad bölümleri yaratıyoruz. Sistem, <em>inode</em> denilen bir disk blok zinciri atar ve bu daha sonra isim bölümü ile ilişkilendirilir. Bu nedenle her bir sabit bağlantı, dosyanın içeriğini içeren belirli bir <em>inode</em> anlamına gelir.</p>
              <p>Bu bilgiyi görebilmek için <code>ls</code> komutunu <code>-i</code> seçeneğiyle birlikte çağırın.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ls -li
total 16
12353539 drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir1
12353540 drwxrwxr-x 2 me me 4096 2018-01-14 16:17 dir2
12353538 -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
12353538 -rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard</code></pre>
              <p>Listenin bu sürümünde, ilk sütun <em>inode</em> numarasıdır ve görebildiğimiz gibi, hem <code>fun</code> hem de <code>fun-hard</code> aynı dosya numarasını paylaşır; bu da aynı dosya olduğunu doğrular.</p>
              <h4 class="h5 mb-2">Sembolik bağlantı oluşturmak</h4>
              <p>Sabit bağlantıların 2 dezavantajının üstesinden gelmek için sembolik bağlantılar oluşturulmuştur.</p>
              <ol>
                <li>Sabit bağlantılar fiziksel aygıtları kapsamaz.</li>
                <li>Sabit bağlantılar dizinleri referanslayamaz, sadece dosyalara referans verir.</li>
              </ol>
              <p>Sembolik bağlantılar, hedef dosya veya dizine bir metin işaretçisi içeren özel bir dosya türüdür. </p>
              <p>Sembolik bağlantı oluşturmak, sabit bağlantı oluşturmaya benzer.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ln -s fun fun-sym
[me@linuxbox playground]$ ln -s ../fun dir1/fun-sym
[me@linuxbox playground]$ ln -s ../fun dir2/fun-sym</code></pre>
              <p>İlk örnek oldukça açık; sabit bağlantı yerine sembolik bağlantı oluşturmak için <code>-s</code> seçeneğini ekliyoruz. Peki ya diğer ikisi? Unutmayın, sembolik bağlantı oluştururken, hedef dosyanın sembolik bağlantıya göre nerede olduğunu gösteren bir metin açıklaması oluşturuyoruz. Aşağıda gösterilen <code>ls</code> çıktısında görebilirsiniz:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ls -l dir1
total 4
-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me    6 2018-01-15 15:17 fun-sym -> ../fun</code></pre>
              <p><code>dir1</code>'deki <code>fun-sym</code> için yaptığımız <code>ls</code> ilk sütünun başındaki <code>l</code>'yi ve <code>../fun</code>'ı işaret ettiğini, bunun sembolik bir bağlantı olduğunu gösterir. Ayrıca, sembolik bağlantı dosya uzunluğunun <code>../fun</code> dizisindeki karakter sayısını (6) gösterdiğine dikkat edin.</p>
              <p>Sembolik bağlantılar oluştururken, aşağıda gösterildiği gibi mutlak yol adları da kullanabiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ln -s /home/me/playground/fun dir1/fun-syms</code></pre>
              <p>Çoğu durumda, göreceli yol adlarının kullanılması tercih edilir çünkü sembolik bağlantı içeren bir dizin ağacının ve referans dosyaların, linkleri bozmadan yeniden adlandırılması ve/veya taşınmasını sağlar.</p>
              <p>Normal dosyalara ek olarak, sembolik bağlantılar dizinleri de referans alabilir.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ln -s dir1 dir1-sym
[me@linuxbox playground]$ ls -l
total 16
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
lrwxrwxrwx 1 me me    4 2018-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2018-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me    3 2018-01-15 15:15 fun-sym -> fun</code></pre>
              <h4 class="h5 mb-2">Dosya ve dizinleri kaldırmak</h4>
              <p>Daha önce ele aldığımız gibi, <code>rm</code> komutu dosyaları ve dizinleri silmek için kullanılır. Şimdi, oyun alanımızı biraz temizleyelim. İlk önce sabit bağlantılardan birini siliyoruz.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ rm fun-hard
[me@linuxbox playground]$ ls -l
total 12
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
lrwxrwxrwx 1 me me    4 2018-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
-rw-r--r-- 3 me me 1650 2018-01-10 16:33 fun
lrwxrwxrwx 1 me me    3 2018-01-15 15:15 fun-sym -> fun</code></pre>
              <p>Beklendiği gibi çalıştı. <code>fun-hard</code> dosyası kayboldu ve <code>fun</code> için gösterilen bağlantı sayısı, dizin listesinin ikinci sütununda belirtildiği gibi 4'ten 3'e düştü. Şimdi, <code>fun</code> dosyasını silelim, ne yaptığını görmek için <code>-i</code> seçeneğini dahil edelim.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ rm -i fun
rm: remove regular file `fun'?</code></pre>
              <p>Komut istemine <code>y</code> girerek dosyayı silin. Şimdi <code>ls</code>'nin çıktısına bakalım. <code>fun-sym</code>'e ne olduğuna dikkat edin! Mevcut olmayan bir dosyaya işaret eden sembolik bir bağlantı olduğunu göreceksiniz.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ ls -l
total 8
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
lrwxrwxrwx 1 me me    4 2018-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2
lrwxrwxrwx 1 me me    3 2018-01-15 15:15 fun-sym -> fun</code></pre>
              <p>Çoğu Linux dağıtımı kırık bağlantıları göstermek için <code>ls</code>'yi yapılandırır. Kırık bir bağlantının varlığı, kendi başına tehlikeli değildir, fakat oldukça dağınıktır. Kırık bir bağlantıyı kullanmaya çalışırsak şunu göreceğiz:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ less fun-sym
fun-sym: No such file or directory</code></pre>
              <p>Hadi biraz temizlik yapalım. Buradaki sembolik bağlantıları sileceğiz:</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ rm fun-sym dir1-sym
[me@linuxbox playground]$ ls -l
total 8
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir1
drwxrwxr-x 2 me me 4096 2018-01-15 15:17 dir2</code></pre>
              <p>Sembolik bağlantılar hakkında hatırlanması gereken bir şey, çoğu dosya işleminin bağlantının kendisinde değil, bağlantının hedefinde gerçekleştirilmesidir. <code>rm</code> bir istisnadır. Bir bağlantıyı sildiğimizde, silinen hedef değil bağlantıdır.</p>
              <p>Sonunda oyun alanımızı kaldıracağız. Bunu yapmak için, ana dizine geri döneceğiz ve oyun alanını ve alt dizinleri dahil tüm içeriğini silmek için özyinelemeli seçenekle (<code>-r</code>) <code>rm</code>'yi kullanacağız.</p>
              <pre><code class="language-bash">[me@linuxbox playground]$ cd
[me@linuxbox ~]$ rm -r playground</code></pre>
            </section>
            <!-- / manipulating files and directories -->

            <!-- working with commands -->
            <section id="section-5">
              <h2 class="section-title-2 mb-2">Komutlarla Çalışmak <a data-scroll="" href="#section-5" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>Buraya kadar, her biri kendi gizemli seçenek ve argümanlarına sahip bir dizi komut gördük. Bu bölümde, bu gizemi kaldırmayı ve hatta kendi komutlarımızı yaratmayı deneyeceğiz. Bu bölümde verilecek komutlar:</p>
              <ul>
                <li><code>type</code> - Komut adının nasıl yorumlandığını gösterir</li>
                <li><code>which</code> - Hangi programın yürütüleceğini görüntüler</li>
                <li><code>help</code> - Yerleşik komutlar için yardım</li>
                <li><code>man</code> - Herhangi bir komutun man sayfalarını görüntüler</li>
                <li><code>apropos</code> - Man sayfaları içinde arama yapar</li>
                <li><code>info</code> - Bir komutun bilgi girişini görüntüler</li>
                <li><code>whatis</code> - Tek satırlık man sayfa açıklamalarını görüntüler</li>
                <li><code>alias</code> - Komutlar için takma ad oluşturur</li>
              </ul>
              <h3 class="h4 mb-2">Komutlar tam olarak nedir?</h3>
              <p>Bir komut dört farklı şeyden biri olabilir:</p>
              <ol>
                <li><code>/usr/bin</code> içinde gördüğümüz tüm dosyalar gibi <strong>yürütülebilir bir program.</strong> Bu kategorideki programlar, C ve C++ ile yazılmış ikili dosyalara derlenebilir programlar veya Shell, Perl, Python, Ruby vb. script dillerinde yazılmış programlar olabilir.</li>
                <li><strong>Kabuğun içinde yerleşik bir komut.</strong> <code>bash</code>, dahili olarak <em>shell builtins</em> adı verilen bir dizi komutu destekler (Örneğin <code>cd</code> komutu).</li>
                <li><strong>Kabuk işlevi.</strong> Kabuk işlevleri, ortama dahil edilmiş minyatür kabuk komut dosyalarıdır. Ortam yapılandırmasını ve kabuk fonksiyonları yazmayı daha sonraki bölümlerde ele alacağız, şimdilik varlıklarının farkında olun.</li>
                <li><strong>Takma ad.</strong> Takma adlar, diğer komutları kullanarak kendimiz tanımlayabildiğimiz komutlardır.</li>
              </ol>
              <h3 class="h4 mb-2">Komutları belirlemek</h3>
              <p>Komutun türünü tam olarak bilmek genellikle faydalıdır ve Linux bunu bulmak için birkaç yol sunar.</p>
              <h4 class="h5 mb-2">type - Komut türünü görüntülemek</h4>
              <p><code>type</code> yerleşik bir komuttur, vereceğiniz komut adının türünü gösterir. Şöyle çalışır:</p>
              <pre><code class="language-bash">type command</code></pre>
              <p><code>command</code>, incelemek istediğimiz komutun adıdır. İşte bazı örnekler:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ type type
type is a shell builtin
[me@linuxbox ~]$ type ls
ls is aliased to `ls --color=tty'
[me@linuxbox ~]$ type cp
cp is /bin/cp</code></pre>
              <p>Burada 3 farklı komutun sonuçlarını görüyoruz. <code>ls</code> komutunun aslında <code>ls</code> komutu için "--color=tty" seçeneği eklenmiş bir takma ad olduğuna dikkat edin. Şimdi <code>ls</code> çıktısının neden renkli göründüğünü biliyoruz!</p>
              <h4 class="h5 mb-2">which - Programın konumunu görüntülemek</h4>
              <p>Bazen sistemde kurulu bir programın birden fazla sürümü olabilir. Bu masaüstü sistemlerde yaygın olmasa da, büyük sunucularda olağandışı değildir. Bir programın tam yerini belirlemek için <code>which</code> komutu kullanılır.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ which ls
/bin/ls</code></pre>
              <p><code>which</code> yalnızca çalıştırılabilir programlar için kullanılır. Yerleşik bir komut için - örneğin <code>cd</code> komutunda - kullanmaya çalıştığımızda ya bir cevap alamayız ya da bir hata mesajı alırız.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ which cd
/usr/bin/which: no cd in (/usr/local/bin:/usr/bin:/bin:/usr/local
/games:/usr/games)</code></pre>
              <p>Bu cevap, "komut bulunamadı"" demenin süslü bir yoludur.</p>
              <h3 class="h4 mb-2">Komut dökümanları</h3>
              <p>Komutların ne olduğunu anladığımıza göre, şimdi her bir komut için mevcut dökümanları arayabiliriz.</p>
              <h4 class="h5 mb-2">help - Kabuk yerleşikleri için yardım</h4>
              <p><code>bash</code>, yerleşik kabuk komutları için kullanılabilen yardım dökümanlarına sahiptir. Kullanmak için komut adından önce <code>help</code> yazın. İşte bir örnek:</p>
              <pre><code class="language-bash">cd: cd [-L|[-P [-e]] [-@]] [dir]
    Change the shell working directory.

    Change the current directory to DIR.  The default DIR is the value of the
    HOME shell variable.

    The variable CDPATH defines the search path for the directory containing
    DIR.  Alternative directory names in CDPATH are separated by a colon (:).
    A null directory name is the same as the current directory.  If DIR begins
    with a slash (/), then CDPATH is not used.

    If the directory is not found, and the shell option `cdable_vars` is set,
    the word is assumed to be  a variable name.  If that variable has a value,
    its value is used for DIR.

    Options:
        -L  force symbolic links to be followed: resolve symbolic links in
      DIR after processing instances of `..`
        -P  use the physical directory structure without following symbolic
      links: resolve symbolic links in DIR before processing instances
      of `..`
        -e  if the -P option is supplied, and the current working directory
      cannot be determined successfully, exit with a non-zero status
        -@  on systems that support it, present a file with extended attributes
            as a directory containing the file attributes

    The default is to follow symbolic links, as if `-L` were specified.
    `..' is processed by removing the immediately previous pathname component
    back to a slash or the beginning of DIR.

    Exit Status:
    Returns 0 if the directory is changed, and if $PWD is set successfully when
    -P is used; non-zero otherwise.</code></pre>
              <p><strong>Notasyon ile ilgili bir not:</strong> Bir komutun sözdizimindeki köşeli parantezler isteğe bağlı öğeleri gösterir. Dikey çubuk karakteri, birbirini dışlayan öğeleri gösterir. Yukarıdaki <code>cd</code> komutu:</p>
              <pre><code class="language-bash">cd [-L|[-P[-e]]] [dir]</code></pre>
              <p>Bu notasyon, <code>cd</code> komutunun isteğe bağlı olarak "-L" veya "-P" ile takip edilebileceğini ve "-P" seçeneği belirtilmişse "-e" seçeneğinin ve ayrıca "dir" argümanının isteğe bağlı olarak eklenebileceğini söylüyor.</p>
              <p><code>cd</code> komutu için <code>help</code> çıktısı kısa ve eksiksiz olsa da, hiçbir şekilde öğretici değildir ve görebildiğimiz gibi, henüz konuşmadığımız birçok şeyden de bahsediliyor! Endişelenmeyin, hepsini anlatacağız.</p>
              <h4 class="h5 mb-2">--help - Kullanım şeklini görüntülemek</h4>
              <p>Çalıştırılabilir programların çoğu, komutun desteklenen sözdizimi ve seçeneklerinin açıklamasını görüntüleyen <code>--help</code> seçeneğini destekler. Örneğin:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ mkdir --help
Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.

Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit

GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;
Full documentation at: &lt;http://www.gnu.org/software/coreutils/mkdir&gt;
or available locally via: info '(coreutils) mkdir invocation'</code></pre>
              <p>Bazı programlar "--help" seçeneğini desteklemez, ancak yine de deneyin. Genellikle, aynı kullanım bilgisini ortaya çıkaracak bir hata mesajı ile sonuçlanır.</p>
              <h4 class="h5 mb-2">man - Bir programın man sayfasını görüntülemek</h4>
              <p>Komut satırı için tasarlanan çoğu çalıştırılabilir program, "manual" veya "man" sayfası adı verilen resmi bir belge sağlar. Bu sayfaları görüntülemek için özel bir program olan <code>man</code> kullanılır.</p>
              <pre><code class="language-bash">man program</code></pre>
              <p>Burada "program" görüntülenecek komutun adıdır.</p>
              <p>Man sayfaları, format olarak birbirinden biraz farklıdır ancak genellikle aşağıdakileri içerir:</p>
              <ul>
                <li>Başlık (sayfanın adı)</li>
                <li>Komut sözdiziminin özeti</li>
                <li>Komut amacının açıklaması</li>
                <li>Komut seçeneklerinin listesi ve açıklaması</li>
              </ul>
              <p>Bununla birlikte, man sayfaları genellikle örnek içermez ve öğrenmek için değil referans amaçlı kullanılır. Örnek olarak, <code>ls</code> komutunun man sayfasını görüntülemeye çalışalım:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ man ls</code></pre>
              <p>Çoğu Linux sisteminde, <code>man</code> komutu sayfaları görüntülemek için <code>less</code> kullanır, bu yüzden tüm bilinen <code>less</code> komutları sayfayı görüntülerken çalışır.</p>
              <p><code>man</code>'ın gösterdiği kılavuz bölümlere ayrılır ve sadece kullanıcı komutlarını değil aynı zamanda sistem yönetim komutlarını, programlama arayüzlerini, dosya formatlarını ve daha fazlasını da kapsar. Aşağıdaki tablo, kılavuzun yerleşimini açıklamaktadır.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col" class="col-lg-4">Bölüm</th>
                        <th scope="col" class="col-lg-8">İçindekiler</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">1</th>
                        <td>Kullanıcı komutları</td>
                      </tr>
                      <tr>
                        <th scope="row">2</th>
                        <td>Çekirdek sistem çağrıları için programlama arayüzleri</td>
                      </tr>
                      <tr>
                        <th scope="row">3</th>
                        <td>C kütüphanesine programlama arayüzleri</td>
                      </tr>
                      <tr>
                        <th scope="row">4</th>
                        <td>Aygıt düğümleri ve sürücüler gibi özel dosyalar</td>
                      </tr>
                      <tr>
                        <th scope="row">5</th>
                        <td>Dosya formatları</td>
                      </tr>
                      <tr>
                        <th scope="row">6</th>
                        <td>Oyunlar ve eğlence (ekran koruyucular vb.)</td>
                      </tr>
                      <tr>
                        <th scope="row">7</th>
                        <td>Çeşitli</td>
                      </tr>
                      <tr>
                        <th scope="row">8</th>
                        <td>Sistem yönetimi komutları</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>Bazen aradığımızı bulmak için kılavuzun belirli bir bölümüne bakmamız gerekir. Bir bölüm numarası belirtmeden, her zaman ilk bölüm örneğini alırız. Bölüm numarası belirlemek için <code>man</code> komutu şöyle kullanılır:</p>
              <pre><code class="language-bash">man section search_term</code></pre>
              <p>İşte bir örnek:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ man 5 passwd</code></pre>
              <p><code>/etc/passwd</code> dosyasının dosya formatını tanımlayan man sayfasını gösterecektir.</p>
              <h4 class="h5 mb-2">apropos - Man sayfaları içinde arama yapmak</h4>
              <p>Bir anahtar kelimeyi man sayfaları içinde aramak mümkündür. Basit ancak bazen faydalıdır. İşte bir örnek:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ apropos partition
addpart (8)          - tell the kernel about the existence of a partition
all-swaps (7)        - event signalling that all swap partitions have been activated
cfdisk (8)           - display or manipulate a disk partition table
cgdisk (8)           - Curses-based GUID partition table (GPT) manipulator
delpart (8)          - tell the kernel to forget about a partition
fdisk (8)            - manipulate disk partition table
fixparts (8)         - MBR partition table repair utility
gdisk (8)            - Interactive GUID partition table (GPT) manipulator
gparted (8)          - GNOME Partition Editor for manipulating disk partitions.
iostat (1)           - Report Central Processing Unit (CPU) statistics and input/output statistics for devices and partitions.
mpartition (1)       - partition an MSDOS hard disk
partprobe (8)        - inform the OS of partition table changes
partx (8)            - tell the kernel about the presence and numbering of on-disk partitions
resizepart (8)       - tell the kernel about the new size of a partition
sfdisk (8)           - display or manipulate a disk partition table
sgdisk (8)           - Command-line GUID partition table (GPT) manipulator for Linux and Unix
systemd-gpt-auto-generator (8) - Generator for automatically discovering and mounting root, /home and /srv partitions, as well as discove...</code></pre>
              <p>Her satırdaki ilk sütun man sayfasının adını ve bölümü gösterir. <code>man</code> komutu ile "-k" seçeneğinin <code>apropos</code> ile aynı şeyi yaptığına dikkat edin.</p>
              <h4 class="h5 mb-2">whatis - Tek satırlık man açıklamalarını görüntülemek</h4>
              <p><code>whatis</code> programı, belirtilen anahtar kelimeyle eşleşen man sayfasının adını ve tek satırlık açıklamasını gösterir:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ whatis ls
ls (1)               - list directory contents</code></pre>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>En sert man sayfası</h4>
                    <p>Görüldüğü gibi, Linux ve diğer Unix benzeri sistemler ile birlikte verilen man sayfalarının referans olması amaçlanmıştır. Pek çok man sayfasının okunması zordur ancak büyük ödül için <code>bash</code> man sayfasına bakmalısınız. Bu kitap için araştırma yaparken, konuların çoğunu ele aldığımdan emin olmak için <code>bash</code> man sayfasını dikkatlice inceledim. Basıldığında, 80 sayfadan uzun ve son derece yoğun bir sayfadır ve yapısı kesinlikle yeni kullanıcılar için bir anlam ifade etmemektedir.</p>
                    <p>Öte yandan eksiksiz, kısa ve özlüdür. Öyleyse okuduğunuz her şeyin bir anlam ifade edeceği günü dört gözle bekleyin.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
              <h4 class="h5 mb-2">info - Bir programın info sayfasını görüntülemek</h4>
              <p>GNU Projesi, kendi programları için man sayfalarına alternatif olarak info sayfalarını sunar. Info sayfaları, <code>info</code> adı verilen bir okuyucu programı ile birlikte görüntülenir. Info sayfaları web sayfaları gibi linklere sahiptir. İşte bir örnek:</p>
              <pre><code>Next: dir invocation,  Up: Directory listing

10.1 ‘ls’: List directory contents
==================================

The ‘ls’ program lists information about files (of any type, including
directories).  Options and file arguments can be intermixed arbitrarily,
as usual.

   For non-option command-line arguments that are directories, by
default ‘ls’ lists the contents of directories, not recursively, and
omitting files with names beginning with ‘.’.  For other non-option
arguments, by default ‘ls’ lists just the file name.  If no non-option
argument is specified, ‘ls’ operates on the current directory, acting as
if it had been invoked with a single argument of ‘.’.

   By default, the output is sorted alphabetically, according to the
locale settings in effect.(1)  If standard output is a terminal, the
output is in columns (sorted vertically) and control characters are
output as question marks; otherwise, the output is listed one per line
and control characters are output as-is.

   Because ‘ls’ is such a fundamental program, it has accumulated many
options over the years.  They are described in the subsections below;
within each section, options are listed alphabetically (ignoring case).
The division of options into the subsections is not absolute, since some
options affect more than one aspect of ‘ls’’s operation.

   Exit status:

     0 success
     1 minor problems  (e.g., failure to access a file or directory not
       specified as a command line argument.  This happens when listing a
       directory in which entries are actively being removed or renamed.)
     2 serious trouble (e.g., memory exhausted, invalid option, failure
       to access a file or directory specified as a command line argument
       or a directory loop)

   Also see *note Common options::.

* Menu:
-----Info: (coreutils.info.gz)ls invocation, 57 lines --Top---------------------------------------------------------------------------------</code></pre>
              <p><code>info</code> programı, her biri tek bir konu içeren ayrı ayrı düğümler halinde yapılandırılmış <em>info dosyalarını</em> okur. Info dosyaları, okuyucuyu düğümden düğüme taşıyabilen bağlantılar içerir. Bir bağlantı, önündeki yıldız işaretiyle tanımlanır ve imleci üzerine getirip Enter tuşuna bastığınızda etkinleşir.</p>
              <p><code>info</code> komutunu çağırırken, <code>info</code> ve ardından isteğe bağlı bir programın adını yazın. Info sayfasını görüntülerken okuyucuyu kontrol etmek için kullanılan komutlar aşağıdaki tabloda listelenmiştir.</p>
              <div class="row">
                <div class="col">
                  <table class="table table-striped boxed">
                    <thead>
                      <tr>
                        <th scope="col" class="col-lg-4">Komut</th>
                        <th scope="col" class="col-lg-8">Eylem</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th scope="row">?</th>
                        <td>Komut yardımını görüntüle</td>
                      </tr>
                      <tr>
                        <th scope="row">PgUp veya Backspace</th>
                        <td>Önceki sayfayı görüntüle</td>
                      </tr>
                      <tr>
                        <th scope="row">PgDn veya Space</th>
                        <td>Sonraki sayfayı görüntüle</td>
                      </tr>
                      <tr>
                        <th scope="row">n</th>
                        <td>Sonraki düğümü görüntüle</td>
                      </tr>
                      <tr>
                        <th scope="row">p</th>
                        <td>Önceki düğümü görüntüle</td>
                      </tr>
                      <tr>
                        <th scope="row">u</th>
                        <td>O anda görüntülenen düğümün ana düğümünü - genellikle bir menüyü - görüntüle.</td>
                      </tr>
                      <tr>
                        <th scope="row">Enter</th>
                        <td>İmleç konumundaki bağlantıyı izle</td>
                      </tr>
                      <tr>
                        <th scope="row">q</th>
                        <td>Çıkış</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>Şimdiye kadar tartıştığımız komut satırı programlarının çoğu, GNU Projesi'nin <em>coreutils</em> paketinin bir parçasıdır,
yani aşağıdakileri yazmak:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ info coreutils</code></pre>
              <p>coreutils paketinde yer alan her programa bağlantı içeren bir menü sayfası gösterecektir.</p>
              <h4 class="h5 mb-2">README ve diğer program dökümantasyon dosyaları</h4>
              <p>Sisteme yüklenen birçok yazılımın dokümantasyonu <code>/usr/share/doc</code> dizininde bulunur. Bunların çoğu düz metin biçiminde saklanır ve <code>less</code> ile görüntülenebilir. Dosyaların bazıları HTML biçimindedir ve bir web tarayıcısı ile görüntülenebilir. ".gz" uzantılı dosyalarla karşılaşabilirsiniz. Bu, onların <code>gzip</code> ile sıkıştırıldığını gösterir. Gzip paketi, sıkıştırılmış metin dosyalarının içeriğini görüntülemek için - <code>less</code>'in özel bir sürümünü olan - <code>zless</code> içerir.</p>
              <h3 class="h4 mb-2">Takma adlarla kendi komutlarımızı oluşturmak</h3>
              <p>Şimdi ilk programlama deneyimimiz için <code>alias</code> komutunu kullanarak kendimize ait bir komut oluşturacağız. Fakat başlamadan önce küçük bir komut satırı numarası açıklamamız gerekiyor. Komutları noktalı virgülle ayırarak bir satıra birden fazla komut yerleştirmek mümkündür:</p>
              <pre><code class="language-bash">command1; command2; command3...</code></pre>
              <p>İşte kullanacağımız örnek:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cd /usr; ls; cd -
bin games include lib local sbin
/home/me
[me@linuxbox ~]$</code></pre>
              <p>Gördüğümüz gibi, tek satırda üç komutu birleştirdik. Önce dizini <code>/usr</code> olarak değiştiriyoruz, sonra dizini listeliyoruz ve (<code>cd -</code> kullanarak) başladığımız yere geri dönüyoruz. Şimdi bu sırayı <code>alias</code> kullanarak yeni bir komuta çevirelim. Yapmamız gereken ilk şey yeni komut için bir isim hayal etmek. "test" i deneyelim. Bunu yapmadan önce "test" adının uygun olup olmadığını anlamak için <code>type</code> komutunu kullanalım:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ type test
test is a shell builtin</code></pre>
              <p>Hata! <code>test</code> zaten alınmış. Hadi <code>foo</code>'yu deneyelim:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ type foo
bash: type: foo: not found</code></pre>
              <p>Harika! "foo" alınmamış. Öyleyse takma adımızı oluşturalım:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ alias foo='cd /usr; ls; cd -'</code></pre>
              <p>Burada gösterilen komut yapısına dikkat edin:</p>
              <pre><code class="language-bash">alias name='string'</code></pre>
              <p>Takma adımızı tanımladıktan sonra, kabuğun bir komut beklediği her yerde kullanabiliriz. Hadi deneyelim:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ foo
bin games include lib
/home/me
[me@linuxbox ~]$</code></pre>
              <p>Takma adımızı görmek için <code>type</code> komutunu tekrar kullanabiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ type foo
foo is aliased to `cd /usr; ls; cd -'</code></pre>
              <p>Bir takma adı kaldırmak için, <code>unalias</code> komutu şöyle kullanılır:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ unalias foo
[me@linuxbox ~]$ type foo
bash: type: foo: not found</code></pre>
              <p>Takma adları mevcut bir komut adlarıyla adlandırmaktan kaçınıyor olsak da, bunu yapmak olağandışı değildir. Bu genellikle bir komutun her çağrısında sıkça istenen bir seçeneği uygulamak için yapılır. Örneğin, daha önce <code>ls</code> komutuna renk desteği eklemek için nasıl takma ad kullanıldığını gördük:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ type ls
ls is aliased to `ls --color=tty'</code></pre>
              <p>Ortamda tanımlanan tüm takma adları görmek için, <code>alias</code> komutunu değişkenler olmadan kullanın. İşte bir Fedora sisteminde varsayılan olarak tanımlanan diğer takma adlar. Ne yaptıklarını anlamaya çalışın:</p>
              <pre><code class="language-bash">[me@linuxbox~]$ alias
alias l.='ls -d .* --color=tty'
alias ll='ls -l --color=tty'
alias ls='ls --color=tty'</code></pre>
              <p>Komut satırında takma ad tanımlarken küçük bir problem oluşur. Kabuk oturumu sona erdiğinde yok olurlar. İlerleyen bölümlerde, her oturum açışınızda ortamı oluşturan dosyalara kendi takma adlarımızı nasıl ekleyeceğimizi göreceğiz, ancak şimdilik ilk adımın tadını çıkarın, kabuk programlama dünyasına küçükte olsa bir adım attınız!</p>
            </section>
            <!-- / working with commands -->

            <!-- redirection -->
            <section id="section-6">
              <h2 class="section-title-2 mb-2">Yönlendirme <a data-scroll="" href="#section-6" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>Komut satırının en havalı özelliği nedir? I/O yönlendirmesi! "I/O" Input/Output (Giriş/Çıkış) anlamına gelir ve bu sayede komutların giriş çıkışını dosyalara yönlendirebilir ve çoklu komutları birbirine bağlayabiliriz. Bu bölümde aşağıdaki komutları öğreneceksiniz:</p>
              <ul>
                <li><code>cat</code> - Dosyaları birleştir</li>
                <li><code>sort</code> - Metnin satırlarını sırala</li>
                <li><code>uniq</code> - Tekrarlanan satırları rapor et veya atla</li>
                <li><code>grep</code> - Bir desene uyan satırları yazdır</li>
                <li><code>wc</code> - Her dosya için yeni satır, sözcük ve bayt sayıları yazdır</li>
                <li><code>head</code> - Bir dosyanın ilk kısmını çıkar</li>
                <li><code>tail</code> - Bir dosyanın son bölümünü çıkar</li>
                <li><code>tee</code> - Standart girişten oku ve standart çıkışa ve dosyalara yaz</li>
              </ul>
              <h3 class="h4 mb-2">Standart giriş, çıkış ve hata</h3>
              <p>Şimdiye kadar kullandığımız programların çoğu aynı şekilde çıktı üretiyor. Bu çıktı genellikle iki türden oluşur:</p>
              <ul>
                <li>Programın sonuçları, yani programın üretmesi için tasarlanan veriler</li>
                <li>Programın nasıl çalıştığını bize bildiren durum ve hata mesajları</li>
              </ul>
              <p><code>ls</code> komutuna baktığımızda, sonuçlarını ve hata mesajlarını ekrana bastığını görebiliriz.</p>
              <p><code>ls</code> gibi programlar "her şey bir dosya" temasını koruyarak aslında sonuçlarını <em>standard output</em> (genellikle <em>stdout</em> olarak ifade edilir) adı verilen özel bir dosyaya ve durum mesajlarını <em>standard error</em> (<em>stderr</em>) adı verilen başka bir dosyaya gönderir. Varsayılan olarak, hem standart çıkış hem de standart hata ekrana bağlanır ve disteki bir dosyaya kaydedilmez.</p>
              <p>Ek olarak, pek çok program standart olarak klavyeye bağlı olan <em>standard input</em>'tan (<em>stdin</em>) girdi alır.</p>
              <p>I/O yönlendirme, çıktının nereye gittiğini ve girdinin nereden geldiğini değiştirmemizi sağlar. Normalde çıktı ekrana gider ve giriş klavyeden gelir, ancak I/O yönlendirmesi ile bunu değiştirebiliriz.</p>
              <h3 class="h4 mb-2">Standart çıkışı yönlendirmek</h3>
              <p>I/O yönlendirme, standart çıkışın nereye gittiğini yeniden tanımlamamızı sağlar. Standart çıkışı ekran yerine başka bir dosyaya yönlendirmek için <code>></code> yönlendirme operatörünü ve ardından dosyanın adını kullanırız. Bunu neden yapmak istiyoruz? Bir komutun çıktısını bir dosyada saklamak genellikle yararlıdır. Örneğin, kabuğa <code>ls</code> komutunun çıktısını ekran yerine <code>ls-output.txt</code> dosyasına göndermesini söyleyebiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt</code></pre>
              <p><code>/usr/bin</code> dizininin uzun listesini oluşturduk ve sonuçları <code>ls-output.txt</code> dosyasına gönderdik. Burada gösterilen komutun yönlendirilmiş çıktısını inceleyelim:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me me 167878 2018-02-01 15:07 ls-output.txt</code></pre>
              <p>Güzel, geniş bir metin dosyası. Dosyaya <code>less</code> ile bakarsak, <code>ls-output.txt</code> dosyasının gerçekten de <code>ls</code> komutumuzun sonuçlarını içerdiğini göreceğiz.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ less ls-output.txt</code></pre>
              <p>Şimdi yönlendirme testimizi biraz değişiklik yaparak tekrarlayalım. Dizin ismini olmayan bir isimle değiştireceğiz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt
ls: cannot access /bin/usr: No such file or directory</code></pre>
              <p>Bir hata mesajı aldık. Varolmayan bir dizini belirttiğimiz için bu mantıklı gelebilir, ancak hata mesajı <code>ls-output.txt</code> dosyasına yönlendirilmek yerine neden ekranda görüntülendi? Cevap, <code>ls</code> programının hata mesajlarını standart çıkışa göndermemesidir. Bunun yerine, iyi yazılmış Unix programlarının çoğu gibi, hata mesajlarını standart hataya gönderir. Standart hatanın nasıl yönlendirileceğini biraz sonra göreceğiz, ancak önce çıktı dosyamıza ne olduğuna bakalım:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me me 0 2018-02-01 15:08 ls-output.txt</code></pre>
              <p>Dosya şimdi sıfır uzunluğa sahip! Bunun nedeni çıktıyı yeniden yönlendirdiğimizde, hedef dosyaya her zaman baştan yazılmasıdır. <code>ls</code> komutumuz sonuç vermedi, yeniden yönlendirme işlemi dosyaya yeniden yazmaya başladı ve ardından hata nedeniyle kesildi. Aslında, bir dosyayı gerçekten kesmemiz gerekirse (veya yeni, boş bir dosya oluşturursak), aşağıdaki gibi bir numara kullanabiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ > ls-output.txt</code></pre>
              <p>Yeniden yönlendirme işlecini komut vermeden kullanmak, varolan bir dosyayı kesecek veya yeni, boş bir dosya oluşturacaktır.</p>
              <p>Öyleyse, yönlendirilmiş çıktıları dosyanın üzerine yazmak yerine bir dosyaya nasıl ekleyebiliriz? Bunun için <code>>></code> yönlendirme operatörünü kullanıyoruz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt</code></pre>
              <p><code>>></code> işlecini kullanmak çıktının dosyaya eklenmesine neden olur. Dosya mevcut değilse, tıpkı <code>></code> işlecinde olduğu gibi oluşturulur. Test edelim:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me me 503634 2018-02-01 15:45 ls-output.txt</code></pre>
              <p>Komutu üç kez tekrarladık, çıktı dosyasıda üç kat daha büyük oldu.</p>
              <h3 class="h4 mb-2">Standart hatayı yönlendirmek</h3>
              <p>Standart hatanın yönlendirilmesi özel bir yönlendirme operatörünün kolaylığına sahip değildir. Standart hatayı yönlendirmek için dosya tanımlayıcısına başvurmamız gerekir. Bir program birkaç numaralı dosya akışından herhangi biri üzerinde çıktı üretebilir. Bu dosya akışlarının ilk üçünü standart giriş, çıkış ve hata olarak adlandırmış olsak da, kabuk bunları dahili olarak sırasıyla 0, 1 ve 2 dosya tanımlayıcıları olarak gösterir. Kabuk, dosya tanımlayıcı numarasını kullanarak dosyaları yönlendirmek için bir notasyon sağlar. Standart hata, 2 numaralı dosya tanımlayıcısı ile aynı olduğundan, standart hatayı bu notasyonla yönlendirebiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt</code></pre>
              <p>"2" dosya tanımlayıcısı, standart hatanın <code>ls-error.txt</code> dosyasına yönlendirilmesi için yönlendirme operatörünün hemen önüne yerleştirilir.</p>
              <h4 class="h5 mb-2">Standart çıkış ve standart hatayı tek bir dosyaya yönlendirmek</h4>
              <p>Bir komutun tüm çıktılarını tek bir dosyada tutmak isteyebileceğiniz durumlar vardır. Bunu yapmak için, hem standart çıkışı hem de standart hatayı aynı anda yönlendirmeliyiz. Bunu yapmanın iki yolu vardır. Burada, kabuğun eski sürümleriyle çalışan geleneksel yol gösterilmektedir:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1</code></pre>
              <p>Bu yöntemi kullanarak iki yönlendirme gerçekleştiriyoruz. Önce standart çıkışı <code>ls-output.txt</code> dosyasına yönlendiriyoruz ve daha sonra dosya tanımlayıcı 2'yi (standart hata) <code>2> & 1</code> notasyonunu kullanarak dosya tanımlayıcı 1'e (standart çıkış) yönlendiriyoruz.</p>
              <div class="row">
                <div class="col">
                  <div class="alert alert-info" role="alert">
                    <h4>Not</h4>
                    <p>Yönlendirmelerin sırasının önemli olduğuna dikkat edin. Standart hatanın yönlendirilmesi her zaman standart çıkışı yönlendirdikten sonra gerçekleşmelidir. Aşağıdaki örnek, standart hatayı <code>ls-output.txt</code> dosyasına yönlendirir:</p>
                    <pre><code class="language-bash">>ls-output.txt 2>&1</code></pre>
                    <p>Ancak, sıra aşağıdaki şekilde değiştirilirse, standart hata ekrana yönlendirilir.</p>
                    <pre><code class="language-bash">2>&1 >ls-output.txt</code></pre>
                    <i class="icon-info-circle"></i>
                  </div>
                </div>
              </div>
              <p>Bash'ın son sürümleri, burada gösterilen bu birleşik yönlendirmeyi gerçekleştirmek için daha modern bir yöntem sağlar:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt</code></pre>
              <p>Bu örnekte, hem standart çıkışı hem de standart hatayı <code>ls-output.txt</code> dosyasına yönlendirmek için <code>&></code> notasyonunu kullanıyoruz. Standart çıkış ve standart hata akışlarını aşağıdaki gibi tek bir dosyaya ekleyebiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /bin/usr &>> ls-output.txt</code></pre>
              <h4 class="h5 mb-2">İstenmeyen çıktılardan kurtulmak</h4>
              <p>Bazen "sükut altındır" ve bir komuttan çıktı almak yerine sadece ondan kurtulmak isteyebilirsiniz. Bu özellikle hata ve durum mesajları için geçerlidir. Sistem, çıktıyı "/dev/null" adlı özel bir dosyaya yönlendirerek bunu yapmanın bir yolunu sunar. Bu dosya, giriş kabul eden ve onunla hiçbir şey yapmayan, genellikle <em>bit bucket</em> olarak adlandırılan bir sistem cihazıdır. Bir komuttaki hata iletilerini bastırmak için şunu yapabiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /bin/usr 2> /dev/null</code></pre>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>Unix kültüründe /dev/null</h4>
                    <p>Bit bucket eski bir Unix konseptidir ve evrenselliği nedeniyle Unix kültürünün birçok yerinde ortaya çıkmıştır. Birisi yorumlarınızı <code>/dev/null</code>'a gönderdiğini söylediğinde, bunun ne anlama geldiğini bilirsiniz. Daha fazla örnek için <a href="https://en.wikipedia.org/wiki/Null_device" target="_blank">/dev/null hakkındaki Wikipedia makalesine</a> gözatın.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
              <h3 class="h4 mb-2">Standart girişi yönlendirmek</h3>
              <p>Şimdiye kadar, standart girişi kullanan herhangi bir komutla karşılaşmadık (aslında var, ancak bu sürprizi biraz sonra ortaya koyacağız), bu yüzden birini  tanıtmamız gerekiyor.</p>
              <h4 class="h5 mb-2">cat - Dosyaları birleştir</h4>
              <p><code>cat</code> komutu bir veya daha fazla dosyayı okur ve bunları standart çıkışa aşağıdaki gibi kopyalar:</p>
              <pre><code class="language-bash">cat [file...]</code></pre>
              <p>Çoğu durumda, <code>cat</code> komutunun <code>DOS</code>'taki <code>TYPE</code> komutuna benzediğini düşünebiliriz. Dosyaları sayfalama olmadan görüntülemek için kullanabiliriz. Örneğin, aşağıdakiler <code>ls-output.txt</code> dosyasının içeriğini görüntüler:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cat ls-output.txt</code></pre>
              <p><code>cat</code> genellikle kısa metin dosyalarını görüntülemek için kullanılır. Birden fazla dosyayı argüman olarak kabul edebildiğinden, dosyaları birleştirmek için de kullanılabilir. Birden çok parçaya bölünmüş büyük bir dosya indirdiğimizi (multimedya dosyaları genellikle Usenet'te bu şekilde bölünür) ve bunları tekrar birleştirmek istediğimizi varsayalım. Dosyalar şu şekilde adlandırılmışsa: <code>movie.mpeg.001 movie.mpeg.002 ... movie.mpeg.099</code> bu komutla aşağıdaki gibi tekrar birleştirebiliriz: </p>
              <pre><code class="language-bash">cat movie.mpeg.0* > movie.mpeg</code></pre>
              <p>Joker karakterler her zaman sıralanmış düzende çalıştığı için, argümanlar doğru sırada düzenlenir.</p>
              <p>Bunların hepsi iyi güzel, ama bunun standart giriş ile ne ilgisi var? Henüz ilgisi yok, ama başka bir şey deneyelim. Argüman olmadan <code>cat</code> komutunu girersek ne olur?</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cat</code></pre>
              <p>Hiçbir şey olmuyor gibi görünebilir, ama gerçekten yapması gereken şeyi yapıyor.</p>
              <p><code>cat</code>'e herhangi bir argüman verilmezse, standart girişi okur ve - standart giriş varsayılan olarak klavyeye bağlı olduğundan - bir şeyler yazmamızı bekler! Aşağıdaki metni eklemeyi ve Enter tuşuna basmayı deneyin:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog</code></pre>
              <p>Ardından, <code>Ctrl-d</code> tuşlayarak (yani Ctrl tuşunu basılı tutun ve "d" tuşuna basın) <code>cat</code>'e standart girişte dosyanın sonuna (EOF) ulaştığını bildirin:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog.
The quick brown fox jumped over the lazy dog.</code></pre>
              <p>Dosya adı argümanı bulunmadığında, <code>cat</code> standart girişi standart çıkışa kopyalar, bu nedenle metin satırımızın tekrarlandığını görürüz. Bu davranışı kısa metin dosyaları oluşturmak için kullanabiliriz. Diyelim ki örneğimizdeki metni içeren <code>lazy_dog.txt</code> adlı bir dosya oluşturmak istedik:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.</code></pre>
              <p>Komutu ve ardından dosyaya kaydetmek istediğiniz metni yazın. Sonunda <code>Ctrl-d</code> tuşlamayı unutmayın. Komut satırını kullanarak dünyanın en aptal kelime işlemcisini hayata geçirdik! Sonuçları görüntülemek için, tekrar <code>cat</code> kullanabiliriz.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cat lazy_dog.txt
The quick brown fox jumped over the lazy dog.</code></pre>
              <p>Artık <code>cat</code> komutunun standart girişi nasıl kabul ettiğini bildiğimize göre, dosya adı argümanlarına ek olarak standart girişi yeniden yönlendirmeyi deneyelim.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.</code></pre>
              <p><code><</code> Yönlendirme işlecini kullanarak, standart girişin kaynağı olan klavyeyi <code>lazy_dog.txt</code> dosyası ile değiştirdiğimizde, sonucun aynı olduğunu görüyoruz. Diğer komutlar, - yakında göreceğimiz gibi - standart girişi daha iyi kullanır.</p>
              <p>Devam etmeden önce, birkaç ilginç seçenek için <code>cat</code> man sayfalarına gözatın.</p>
              <h3 class="h4 mb-2">Boru hatları</h3>
              <p>Komutların standart girişten veri okuma ve standart çıkışa gönderme yeteneği, boru hatları (pipelines) adı verilen bir kabuk özelliğini kullanılır. Boru operatörü <code>|</code> (dikey çubuk) ile, bir komutun standart çıkışı başka bir komutun standart girişine bağlanabilir.</p>
              <pre><code class="language-bash">command1 | command2</code></pre>
              <p>Bunu tam olarak göstermek için bazı komutlara ihtiyacımız olacak. Sonuçlarını standart çıkışa gönderen herhangi bir komutun çıktısını sayfa sayfa görüntülemek için <code>less</code> kullanabiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls -l /usr/bin | less</code></pre>
              <p>Son derece kullanışlı! Bu tekniği kullanarak, standart çıktı üreten herhangi bir komutun çıktısını rahatlıkla inceleyebiliriz.</p>
              <div class="row">
                <div class="col">
                  <div class="alert alert-warning" role="alert">
                    <h4>> ve | arasındaki fark</h4>
                    <p>İlk bakışta aradaki farkı anlamak zor olabilir. Basitçe söylemek gerekirse, yönlendirme operatörü <code>></code> bir komutu bir dosyaya bağlarken, boru hattı <code>|</code> operatörü bir komutun çıkışını ikinci bir komutun girişine bağlar.</p>
                    <pre><code class="language-bash">command1 > file1
command1 | command2</code></pre>
                    <p>Birçok insan boru hatlarını öğrenirken - sadece ne olduğunu görmek için - aşağıdakileri deneyecek:</p>
                    <pre><code class="language-bash">command1 > command2</code></pre>
                    <p>Cevap: Bazen gerçekten kötü bir şey.</p>
                    <p>İşte bir okurumuz tarafından gönderilen gerçek bir örnek. Süper kullanıcı olarak bunu yaptı:</p>
                    <pre><code class="language-bash"># cd /usr/bin
# ls > less</code></pre>
                    <p>İlk komut onu çoğu programın saklandığı <code>/usr/bin</code> dizinine getirdi ve ikinci komut kabuğa <code>ls</code> komutunun çıktısını <code>less</code> dosyasının üzerine yazmasını söyledi. <code>/usr/bin</code> dizini zaten <code>less</code> (less programı) adında bir dosya içerdiğinden, ikinci komut <code>less</code> program dosyasının üzerine <code>ls</code>'den gelen metni yazmış ve böylece sistemindeki <code>less</code> programını yok etmiştir.</p>
                    <p>Buradaki ders, yeniden yönlendirme operatörünün sessizce dosya oluşturması veya üzerine yazmasıdır, bu yüzden ona karşı dikkatli olmanız gerekir.</p>
                    <i class="icon-alert-circle"></i>
                  </div>
                </div>
              </div>
              <h4 class="h5 mb-2">Filtreler</h4>
              <p>Boru hatları genellikle veriler üzerinde karmaşık işlemler gerçekleştirmek için kullanılır. Boru hatları ile birkaç komutu bir araya getirmek mümkündür. Sıklıkla, bu şekilde kullanılan komutlara filtre denir. Filtreler girdiyi alır, bir şekilde değiştirir ve sonra çıktı üretir. İlk filtremizde sıralamayı deneyeceğiz. <code>/bin</code> ve <code>/usr/bin</code> içindeki tüm yürütülebilir programların birleşik bir listesini yapmak, bunları sıralamak ve ortaya çıkan listeyi görüntülemek istediğimizi düşünün:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls /bin /usr/bin | sort | less</code></pre>
              <p>İki dizin (<code>/bin</code> ve <code>/usr/bin</code>) belirttiğimizden, <code>ls</code>'nin çıktısı iki ayrı sıralı listeden oluşacaktır. Boru hattımıza sıralama ekleyerek verileri tek, sıralanmış bir liste oluşturacak şekilde değiştirdik.</p>
              <h4 class="h5 mb-2">uniq - Tekrarlanan satırları bildir veya atla</h4>
              <p><code>uniq</code> komutu genellikle <code>sort</code> ile birlikte kullanılır. <code>uniq</code>, standart girişten veya bir dosyadan sıralı veri listesi kabul eder (ayrıntılar için <code>uniq</code> man sayfasına bakın) ve varsayılan olarak tekrarları listeden kaldırır. Bu nedenle, listemizde hiçbir tekrarlamanın olmadığından emin olmak için (yani, <code>/bin</code> ve <code>/usr/bin</code> dizinlerinde aynı ada sahip olan tüm programlar), boru hattımıza <code>uniq</code> ekleyeceğiz.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less</code></pre>
              <p>Bu örnekte, <code>sort</code> komutunun çıktısından tekrarları kaldırmak için <code>uniq</code> kullanıyoruz. Bunun yerine tekrarlananların listesini görmek istiyorsak, "-d" seçeneğini şu şekilde ekliyoruz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less</code></pre>
              <h4 class="h5 mb-2">wc - Satır, kelime ve karakter sayılarını yazdır</h4>
              <p><code>wc</code> (word count) komutu, dosyalarda bulunan satır, kelime ve karakter sayısını görüntülemek için kullanılır. İşte bir örnek:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ wc ls-output.txt
7902 64566 503634 ls-output.txt</code></pre>
              <p>Bu durumda, üç şeyi yazdırır: <code>ls-output.txt</code> dosyasında bulunan satır, kelime ve karakter sayıları. Komutu argüman olmadan yürütürseniz (önceki komutlarda olduğu gibi) standart girişi kabul eder. "-l" seçeneği çıktıyı satır sayısıyla sınırlar. Bir boru hattına <code>wc</code> eklemek, birşeyleri saymanın kullanışlı bir yoludur. Sıralı listemizde bulunan öğe sayısını görüntülemek için bunu yapabiliriz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
2728</code></pre>
              <h4 class="h5 mb-2">grep - Patern ile eşleşen satırları yazdır</h4>
              <p><code>grep</code>, dosyalardaki metin paternlerini bulmak için kullanılan güçlü bir programdır. Bu şekilde kullanılır:</p>
              <pre><code class="language-bash">grep pattern [file...]</code></pre>
              <p><code>grep</code> dosyada bir "patern" ile karşılaştığında, onu içeren satırları yazdırır. <code>grep</code>'in eşleşebileceği desenler çok karmaşık olabilir, ancak şimdilik basit metin eşleşmelerine odaklanacağız. İlerleyen bölümlerde <em>düzenli ifadeler</em> adı verilen gelişmiş paternleri ele alacağız.</p>
              <p>Diyelim ki adında <code>zip</code> kelimesi geçen tüm programları bulmak istedik. Böyle bir arama, sistemimizdeki dosya sıkıştırmayla ilgili bazı programlar hakkında bize fikir verebilir.</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
gzip
unzip
zip
zipcloak
zipgrep
zipinfo
zipnote
zipsplit</code></pre>
              <p><code>grep</code> için birkaç kullanışlı seçenek:</p>
              <ul>
                <li><code>-i</code>, arama yapılırken <code>grep</code>'in büyük/küçük harfleri yoksaymasına neden olur (normalde aramalar büyük/küçük harfe duyarlıdır)</li>
                <li><code>-v</code>, <code>grep</code>'e yalnızca paternle eşleşmeyen satırları yazdırmasını söyler.</li>
              </ul>
              <h4 class="h5 mb-2">head / tail - Dosyaların ilk / son kısmını yazdır</h4>
              <p>Bazen bir komutun tüm çıktılarına ihtiyacımız olmayabilir. Sadece ilk birkaç satırı veya son birkaç satırı isteyebiliriz. <code>head</code> komutu bir dosyanın ilk on satırını ve <code>tail</code> komutu son on satırı yazdırır. Varsayılan olarak, her iki komut da on satır metin yazdırır, ancak bu <code>-n</code> seçeneğiyle ayarlanabilir.</p>
              <pre><code class="language-bash">[me@linuxbox~]$ head -n 5 ls-output.txt
total 343496
-rwxr-xr-x 1 root root  31316 2007-12-05 08:58 [
-rwxr-xr-x 1 root root   8240 2007-12-09 13:39 411toppm
-rwxr-xr-x 1 root root 111276 2007-11-26 14:27 a2p
-rwxr-xr-x 1 root root  25368 2006-10-06 20:16 a52dec
[me@linuxbox~]$ tail -n 5 ls-output.txt
-rwxr-xr-x 1 root root   5234 2007-06-27 10:56 znew
-rwxr-xr-x 1 root root    691 2005-09-10 04:21 zonetab2pot.py
-rw-r--r-- 1 root root    930 2007-11-01 12:23 zonetab2pot.pyc
-rw-r--r-- 1 root root    930 2007-11-01 12:23 zonetab2pot.pyo
lrwxrwxrwx 1 root root      6 2016-01-31 05:22 zsoelim -> soelim</code></pre>
              <p>Bu komutlar boru hatlarında da kullanılabilir:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls /usr/bin | tail -n 5
znew
zonetab2pot.py
zonetab2pot.pyc
zonetab2pot.pyo
zsoelim</code></pre>
              <p><code>tail</code>, dosyaları gerçek zamanlı olarak görüntülememizi sağlayan bir seçeneğe sahiptir. Bu, log dosyalarını izlemek için kullanışlıdır. Aşağıdaki örnekte, <code>/var/log</code> içindeki <code>messages</code> (veya <code>messages</code> bulunamıyorsa <code>/var/log/syslog</code>) dosyasına bakacağız. <code>/var/log/messages</code> dosyası güvenlikle ilgili bilgileri içerebileceğinden, bazı Linux dağıtımlarında süper kullanıcı yetkileri gerekebilir:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
Feb 8 13:40:05 twin4 dhclient: bound to 192.168.1.4 -- renewal in
1652 seconds.
Feb 8 13:55:32 twin4 mountd[3953]: /var/NFSv4/musicbox exported to
both 192.168.1.0/24 and twin7.localdomain in
192.168.1.0/24,twin7.localdomain
Feb 8 14:07:37 twin4 dhclient: DHCPREQUEST on eth0 to 192.168.1.1
port 67
Feb 8 14:07:37 twin4 dhclient: DHCPACK from 192.168.1.1
Feb 8 14:07:37 twin4 dhclient: bound to 192.168.1.4 -- renewal in
1771 seconds.
Feb 8 14:09:56 twin4 smartd[3468]: Device: /dev/hda, SMART
Prefailure Attribute: 8 Seek_Time_Performance changed from 237 to 236
Feb 8 14:10:37 twin4 mountd[3953]: /var/NFSv4/musicbox exported to
both 192.168.1.0/24 and twin7.localdomain in
192.168.1.0/24,twin7.localdomain
Feb 8 14:25:07 twin4 sshd(pam_unix)[29234]: session opened for user
me by (uid=0)
Feb 8 14:25:36 twin4 su(pam_unix)[29279]: session opened for user
root by me(uid=500)</code></pre>
              <p>"-f" seçeneğini kullandığınızda, <code>tail</code> dosyayı izlemeye devam eder ve yeni satırlar eklendiğinde hemen ekranda görünür. Bu, <code>Ctrl-c</code> tuşlarına basana kadar devam eder.</p>
              <h4 class="h5 mb-2">tee - Standart girişi oku, standat çıkış ve dosyalara kopyala</h4>
              <p>Sıhhi tesisat metaforumuza uygun olarak, <code>tee</code> komutu boru hattımızda "t" şeklinde bir bağlantı noktası oluşturur. <code>tee</code> programı standart girişi okur ve hem standart çıkışa (verilerin ardışık düzende devam etmesine izin verir) hem de bir veya daha fazla dosyaya kopyalar. Bu, bir boru hattında işlenen içeriği yakalamak için kullanışlıdır. Aşağıda önceki örneklerimizden birini tekrarlıyoruz, bu kez - tüm dizin listesini <code>ls.txt</code> dosyasına kaydetmek için - <code>tee</code> komutunu <code>grep</code> komutunun önüne ekliyoruz:</p>
              <pre><code class="language-bash">[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
gunzip
gzip
unzip
zip
zipcloak
zipgrep
zipinfo
zipnote
zipsplit</code></pre>
            </section>
            <!-- / redirection -->

            <!-- seeing the world as the shell sees it -->
            <section id="section-7">
              <h2 class="section-title-2 mb-2">Dünyayı Kabuk Olarak Görmek <a data-scroll="" href="#section-7" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>...</p>
              <p></p>
              <p></p>
              <p></p>
              <p></p>
              <p></p>
              <p></p>
            </section>
            <!-- / seeing the world as the shell sees it -->

            <!-- advanced keyboard tricks -->
            <section id="section-8">
              <h2 class="section-title-2 mb-2">Klavye Püf Noktaları <a data-scroll="" href="#section-8" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>...</p>
            </section>
            <!-- / advanced keyboard tricks -->

            <!-- permissions -->
            <section id="section-9">
              <h2 class="section-title-2 mb-2">İzinler <a data-scroll="" href="#section-9" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>...</p>
            </section>
            <!-- / permissions -->

            <!-- processes -->
            <section id="section-10">
              <h2 class="section-title-2 mb-2">Süreçler <a data-scroll="" href="#section-10" class="anchor" data-toggle="tooltip" data-placement="top" title="" data-original-title="Linki kopyala"><i class="icon-hash"></i></a></h2>
              <p>...</p>
            </section>
            <!-- / processes -->

          </article>
          <!-- / content -->

          <!-- scroll indicator -->
          <div class="col-lg-1 d-none d-lg-block">
            <div class="sticky sticky-with-header text-right">
              <div id="pageProgress" class="page-progress" data-anchor-target="#content">
                <div data-anchor-target="#content" data-top-top="height:0%;" data-bottom-bottom="height:100%;"></div>
              </div>
            </div>
          </div>
          <!-- / scroll indicator -->

        </div>
      </div>
    </section>

    <!-- go top -->
    <div class="half">
      <span class="half-bg bg-dark"></span>
      <div class="container">
        <div class="row">
          <div class="col text-center">
            <div class="btn-frame">
              <a data-scroll href="#top" class="btn btn-top btn-primary btn-ico btn-lg btn-rounded"><i class="icon-arrow-up2 fs-22"></i></a>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- / go top -->

    <!-- footer -->
    <footer class="bg-dark">
      <div class="container">
        <div class="row gutter-3">
          <div class="col-12 col-md-2">
            <a href=""><img src="assets/images/logo-white.svg" alt="Logo"></a>
          </div>
          <div class="col-12 col-md-6 text-white">
            <p class="mb-5"><a href="http://linuxcommand.org/" target="blank" rel="nofollow">The Linux Command Line</a> kitabından çevirilerek hazırlanmıştır. Bu içerik <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" target="blank" rel="nofollow">Attribution-NonCommercial-NoDerivs 3.0 Unported</a> lisansı altındadır.</p>
            <p>Yayıncı, <a href="http://www.melihkocaturk.com/" target="blank">Melih Kocatürk</a></p>
          </div>
          <div class="col-12 col-md-4 col-lg-2 ml-auto text-md-right">
            <div class="dropdown">
              <button class="btn btn-inverted btn-block dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                Türkçe
              </button>
              <div class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                <a class="dropdown-item" href="http://linuxcommand.org/" target="blank" rel="nofollow">English</a>
              </div>
            </div>
          </div>
        </div>
      </div>
    </footer>
    <!-- / footer -->

    <script src="assets/js/vendor.js"></script>
    <script src="assets/js/app.js"></script>
  </body>
</html>
